package ecs

import (
	"sync"
	"runtime"
)

// Warning: This is an autogenerated file. Do not modify!!

{{range $i, $element := .Views}}

// --------------------------------------------------------------------------------
// - View {{len $element}}
// --------------------------------------------------------------------------------

// Represents a view of data in a specific world. Provides access to the components specified in the generic block
type View{{len $element}}[{{join $element ","}} any] struct {
	world *World
	filter filterList
	{{range $ii, $arg := $element}}
	storage{{$arg}} *componentStorage[{{$arg}}]{{end}}
}

// implement the initializer interface so that it can be automatically created and injected into systems
func (v *View{{len $element}}[{{join $element ","}}]) Initialize(world *World) any {
	// TODO: filters need to be a part of the query type
	return Query{{len $element}}[{{join $element ","}}](world)
}


// Creates a View for the specified world with the specified component filters.
func Query{{len $element}}[{{join $element ","}} any](world *World, filters ...Filter) *View{{len $element}}[{{join $element ","}}] {
{{range $ii, $arg := $element}}
	storage{{$arg}} := getStorage[{{$arg}}](world.engine){{end}}

{{range $ii, $arg := $element}}
	var {{$arg}}{{$arg}} {{$arg}}{{end}}

	comps := []CompId{
{{range $ii, $arg := $element}}
		name({{$arg}}{{$arg}}),{{end}}

	}
	filterList := newFilterList(comps, filters...)
	filterList.regenerate(world)

	v := &View{{len $element}}[{{join $element ","}}]{
		world: world,
		filter: filterList,
{{range $ii, $arg := $element}}
		storage{{$arg}}: storage{{$arg}},{{end}}
	}
	return v
}

// Reads a pointer to the underlying component at the specified id.
// Read will return even if the specified id doesn't match the filter list
// Read will return the value if it exists, else returns nil.
// If you execute any ecs.Write(...) or ecs.Delete(...) this pointer may become invalid.
func (v *View{{len $element}}[{{join $element ","}}]) Read(id Id) (*{{join $element ",*"}}) {
	if id == InvalidEntity {
		return {{with len $element}}{{nils .}}{{end}}
	}

	loc, ok := v.world.arch.Get(id)
	if !ok {
		return {{with len $element}}{{nils .}}{{end}}
	}
	lookup := v.world.engine.lookup[loc.archId]
	if lookup == nil {
		panic("LookupList is missing!")
	}
	index := int(loc.index)

{{range $ii, $arg := $element}}
	var ret{{$arg}} *{{$arg}}{{end}}

	{{range $ii, $arg := $element}}	slice{{$arg}}, ok := v.storage{{$arg}}.slice.Get(loc.archId)
	if ok {
		ret{{$arg}} = &slice{{$arg}}.comp[index]
	}
	{{end}}

	return {{retlist $element}}
}

// Counts the number of entities that match this query
func (v *View{{len $element}}[{{join $element ","}}]) Count() int {
	v.filter.regenerate(v.world)

	total := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil { panic("LookupList is missing!") }

		total += lookup.Len()
	}
	return total
}

// Maps the lambda function across every entity which matched the specified filters.
func (v *View{{len $element}}[{{join $element ","}}]) MapId(lambda func(id Id, {{lambdaArgs $element}})) {
	v.filter.regenerate(v.world)

	{{range $ii, $arg := $element}}
	var slice{{$arg}} *componentList[{{$arg}}]
	var comp{{$arg}} []{{$arg}}
	var ret{{$arg}} *{{$arg}}
	{{end}}

	for _, archId := range v.filter.archIds {
		{{range $ii, $arg := $element}}
		slice{{$arg}}, _ = v.storage{{$arg}}.slice.Get(archId){{end}}

		lookup := v.world.engine.lookup[archId]
		if lookup == nil { panic("LookupList is missing!") }
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }
		ids := lookup.id


		// TODO - this flattened version causes a mild performance hit. But the other one combinatorially explodes. I also cant get BCE to work with it. See option 2 for higher performance.
		{{range $ii, $arg := $element}}
		comp{{$arg}} = nil
		if slice{{$arg}} != nil {
			comp{{$arg}} = slice{{$arg}}.comp
		}{{end}}

		{{range $ii, $arg := $element}}
		ret{{$arg}} = nil{{end}}
		for idx := range ids {
			if ids[idx] == InvalidEntity { continue } // Skip if its a hole
			{{range $ii, $arg := $element}}
			if comp{{$arg}} != nil { ret{{$arg}} = &comp{{$arg}}[idx] }{{end}}
			lambda(ids[idx], {{retlist $element}})
		}
	}
}

// Maps the lambda function across every entity which matched the specified filters. Components are split based on the number of OS threads available.
func (v *View{{len $element}}[{{join $element ","}}]) MapIdParallel(lambda func(id Id, {{lambdaArgs $element}})) {
	v.filter.regenerate(v.world)

	{{range $ii, $arg := $element}}
	var slice{{$arg}} *componentList[{{$arg}}]
	{{end}}

	// 1. Calculate work
	// 2. Calculate number of threads to execute with
	// 3. Greedy divide work among N threads
	// 4. Execute for each in its own goroutine

	// 1. Calculate work
	totalWork := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		// Each id represents an entity that holds the requested component(s)
		// Each hole represents a deleted entity that used to hold the requested component(s)
		totalWork += len(lookup.id) // - len(lookup.holes)
	}

	// Nothing to do if there is no work
	if totalWork == 0 { return }

	// 2. Calculate number of threads to execute with
	numThreads := runtime.NumCPU()

	// Ensure that the number of threads we plan to use is <= total amount of work
	numThreads = min(totalWork, numThreads)

	var waitGroup sync.WaitGroup

	type workItem struct{
		ids []Id
		{{range $ii, $arg := $element}}
		comp{{$arg}} []{{$arg}}
		{{end}}
	}
	workChannel := make(chan workItem)

	for i := 0; i < numThreads; i++ {
		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			for {
				work, ok := <-workChannel
				if !ok {
					return
				}

				{{range $ii, $arg := $element}}
				var ret{{$arg}} *{{$arg}}{{end}}
				for idx := range work.ids {
					if work.ids[idx] == InvalidEntity { continue } // Skip if its a hole
					{{range $ii, $arg := $element}}
					if work.comp{{$arg}} != nil { ret{{$arg}} = &work.comp{{$arg}}[idx] }{{end}}
					lambda(work.ids[idx], {{retlist $element}})
				}
			}
		}()
	}

	// 3. Greedy divide work among N threads
	// Simple algorithm:
	// a. Find an evenly balanced distribution per thread
	// b. Generate all work until it gets consumed
	workPerThread := totalWork / numThreads

	// Generate
	{{range $ii, $arg := $element}}
	var comp{{$arg}} []{{$arg}}
	{{end}}
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		ids := lookup.id

		{{range $ii, $arg := $element}}
		slice{{$arg}}, _ = v.storage{{$arg}}.slice.Get(archId){{end}}

		{{range $ii, $arg := $element}}
		comp{{$arg}} = nil
		if slice{{$arg}} != nil {
			comp{{$arg}} = slice{{$arg}}.comp
		}{{end}}

		// workPerformed := 0

		start := 0
		end := 0
		numWorkItems := (len(ids) / workPerThread) + 1
		actualWorkPerThread := (len(ids) / numWorkItems) + 1
		for i := 0; i < numWorkItems; i++ {
			start = i * actualWorkPerThread
			end = (i+1) * actualWorkPerThread
			if end > len(ids) {
				end = len(ids)
			}

			// workPerformed += len(ids[start:end])
			workChannel <- workItem{
				ids: ids[start:end],
				{{range $ii, $arg := $element}}
				comp{{$arg}}: comp{{$arg}}[start:end],
				{{end}}
			}
		}

		// if workPerformed != len(ids) {
		// 	panic("wrong")
		// }
	}

	close(workChannel)
	waitGroup.Wait()
}

// Deprecated: This API is a tentative alternative way to map
func (v *View{{len $element}}[{{join $element ","}}]) MapSlices(lambda func(id []Id, {{sliceLambdaArgs $element}})) {
	v.filter.regenerate(v.world)

	id := make([][]Id, 0)

	{{range $ii, $arg := $element}}
	sliceList{{$arg}} := make([][]{{$arg}}, 0){{end}}

	for _, archId := range v.filter.archIds {
		{{range $ii, $arg := $element}}
		slice{{$arg}}, ok := v.storage{{$arg}}.slice.Get(archId)
		if !ok { continue }{{end}}

		lookup := v.world.engine.lookup[archId]
		if lookup == nil { panic("LookupList is missing!") }
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }

		id = append(id, lookup.id)
		{{range $ii, $arg := $element}}
		sliceList{{$arg}} = append(sliceList{{$arg}}, slice{{$arg}}.comp){{end}}
	}

	for idx := range id {
		lambda(id[idx],
			{{range $ii, $arg := $element}}sliceList{{$arg}}[idx],{{end}}
		)
	}
}
{{end}}
