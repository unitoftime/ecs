package ecs

import (
	"runtime"
	"sync"
)

// Warning: This is an autogenerated file. Do not modify!!

// --------------------------------------------------------------------------------
// - View 1
// --------------------------------------------------------------------------------

// Represents a view of data in a specific world. Provides access to the components specified in the generic block
type View1[A any] struct {
	world  *World
	filter filterList

	storageA *componentStorage[A]
}

// implement the intializer interface so that it can be automatically created and injected into systems
func (v *View1[A]) initialize(world *World) any {
	// TODO: filters need to be a part of the query type
	return Query1[A](world)
}

// Creates a View for the specified world with the specified component filters.
func Query1[A any](world *World, filters ...Filter) *View1[A] {

	storageA := getStorage[A](world.engine)

	var AA A

	comps := []CompId{

		name(AA),
	}
	filterList := newFilterList(comps, filters...)
	filterList.regenerate(world)

	v := &View1[A]{
		world:  world,
		filter: filterList,

		storageA: storageA,
	}
	return v
}

// Reads a pointer to the underlying component at the specified id.
// Read will return even if the specified id doesn't match the filter list
// Read will return the value if it exists, else returns nil.
// If you execute any ecs.Write(...) or ecs.Delete(...) this pointer may become invalid.
func (v *View1[A]) Read(id Id) *A {
	if id == InvalidEntity {
		return nil
	}

	loc, ok := v.world.arch.Get(id)
	if !ok {
		return nil
	}
	lookup := v.world.engine.lookup[loc.archId]
	if lookup == nil {
		panic("LookupList is missing!")
	}
	// index, ok := lookup.index.Get(id)
	// if !ok {
	// 	return nil
	// }
	index := int(loc.index)

	var retA *A

	sliceA, ok := v.storageA.slice.Get(loc.archId)
	if ok {
		retA = &sliceA.comp[index]
	}

	return retA
}

// Counts the number of entities that match this query
func (v *View1[A]) Count() int {
	v.filter.regenerate(v.world)

	total := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		total += lookup.Len()
	}
	return total
}

// Maps the lambda function across every entity which matched the specified filters.
func (v *View1[A]) MapId(lambda func(id Id, a *A)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]
	var compA []A
	var retA *A

	for _, archId := range v.filter.archIds {

		sliceA, _ = v.storageA.slice.Get(archId)

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }
		ids := lookup.id

		// TODO - this flattened version causes a mild performance hit. But the other one combinatorially explodes. I also cant get BCE to work with it. See option 2 for higher performance.

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}

		retA = nil
		for idx := range ids {
			if ids[idx] == InvalidEntity {
				continue
			} // Skip if its a hole

			if compA != nil {
				retA = &compA[idx]
			}
			lambda(ids[idx], retA)
		}
	}
}

// Maps the lambda function across every entity which matched the specified filters. Components are split based on the number of OS threads available.
func (v *View1[A]) MapIdParallel(lambda func(id Id, a *A)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]

	// 1. Calculate work
	// 2. Calculate number of threads to execute with
	// 3. Greedy divide work among N threads
	// 4. Execute for each in its own goroutine

	// 1. Calculate work
	totalWork := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		// Each id represents an entity that holds the requested component(s)
		// Each hole represents a deleted entity that used to hold the requested component(s)
		totalWork += len(lookup.id) // - len(lookup.holes)
	}

	// 2. Calculate number of threads to execute with
	numThreads := runtime.NumCPU()
	var waitGroup sync.WaitGroup

	type workItem struct {
		ids []Id

		compA []A
	}
	workChannel := make(chan workItem)

	for i := 0; i < numThreads; i++ {
		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			for {
				work, ok := <-workChannel
				if !ok {
					return
				}

				var retA *A
				for idx := range work.ids {
					if work.ids[idx] == InvalidEntity {
						continue
					} // Skip if its a hole

					if work.compA != nil {
						retA = &work.compA[idx]
					}
					lambda(work.ids[idx], retA)
				}
			}
		}()
	}

	// 3. Greedy divide work among N threads
	// Simple algorithm:
	// a. Find an evenly balanced distribution per thread
	// b. Generate all work until it gets consumed
	workPerThread := totalWork / numThreads

	// Generate

	var compA []A

	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		ids := lookup.id

		sliceA, _ = v.storageA.slice.Get(archId)

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}

		// workPerformed := 0

		start := 0
		end := 0
		numWorkItems := (len(ids) / workPerThread) + 1
		actualWorkPerThread := (len(ids) / numWorkItems) + 1
		for i := 0; i < numWorkItems; i++ {
			start = i * actualWorkPerThread
			end = (i + 1) * actualWorkPerThread
			if end > len(ids) {
				end = len(ids)
			}

			// workPerformed += len(ids[start:end])
			workChannel <- workItem{
				ids: ids[start:end],

				compA: compA[start:end],
			}
		}

		// if workPerformed != len(ids) {
		// 	panic("wrong")
		// }
	}

	close(workChannel)
	waitGroup.Wait()
}

// Deprecated: This API is a tentative alternative way to map
func (v *View1[A]) MapSlices(lambda func(id []Id, a []A)) {
	v.filter.regenerate(v.world)

	id := make([][]Id, 0)

	sliceListA := make([][]A, 0)

	for _, archId := range v.filter.archIds {

		sliceA, ok := v.storageA.slice.Get(archId)
		if !ok {
			continue
		}

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }

		id = append(id, lookup.id)

		sliceListA = append(sliceListA, sliceA.comp)
	}

	for idx := range id {
		lambda(id[idx],
			sliceListA[idx],
		)
	}
}

// --------------------------------------------------------------------------------
// - View 2
// --------------------------------------------------------------------------------

// Represents a view of data in a specific world. Provides access to the components specified in the generic block
type View2[A, B any] struct {
	world  *World
	filter filterList

	storageA *componentStorage[A]
	storageB *componentStorage[B]
}

// implement the intializer interface so that it can be automatically created and injected into systems
func (v *View2[A, B]) initialize(world *World) any {
	// TODO: filters need to be a part of the query type
	return Query2[A, B](world)
}

// Creates a View for the specified world with the specified component filters.
func Query2[A, B any](world *World, filters ...Filter) *View2[A, B] {

	storageA := getStorage[A](world.engine)
	storageB := getStorage[B](world.engine)

	var AA A
	var BB B

	comps := []CompId{

		name(AA),
		name(BB),
	}
	filterList := newFilterList(comps, filters...)
	filterList.regenerate(world)

	v := &View2[A, B]{
		world:  world,
		filter: filterList,

		storageA: storageA,
		storageB: storageB,
	}
	return v
}

// Reads a pointer to the underlying component at the specified id.
// Read will return even if the specified id doesn't match the filter list
// Read will return the value if it exists, else returns nil.
// If you execute any ecs.Write(...) or ecs.Delete(...) this pointer may become invalid.
func (v *View2[A, B]) Read(id Id) (*A, *B) {
	if id == InvalidEntity {
		return nil, nil
	}

	loc, ok := v.world.arch.Get(id)
	if !ok {
		return nil, nil
	}
	lookup := v.world.engine.lookup[loc.archId]
	if lookup == nil {
		panic("LookupList is missing!")
	}
	// index, ok := lookup.index.Get(id)
	// if !ok {
	// 	return nil, nil
	// }
	index := int(loc.index)

	var retA *A
	var retB *B

	sliceA, ok := v.storageA.slice.Get(loc.archId)
	if ok {
		retA = &sliceA.comp[index]
	}
	sliceB, ok := v.storageB.slice.Get(loc.archId)
	if ok {
		retB = &sliceB.comp[index]
	}

	return retA, retB
}

// Counts the number of entities that match this query
func (v *View2[A, B]) Count() int {
	v.filter.regenerate(v.world)

	total := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		total += lookup.Len()
	}
	return total
}

// Maps the lambda function across every entity which matched the specified filters.
func (v *View2[A, B]) MapId(lambda func(id Id, a *A, b *B)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]
	var compA []A
	var retA *A

	var sliceB *componentList[B]
	var compB []B
	var retB *B

	for _, archId := range v.filter.archIds {

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }
		ids := lookup.id

		// TODO - this flattened version causes a mild performance hit. But the other one combinatorially explodes. I also cant get BCE to work with it. See option 2 for higher performance.

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}

		retA = nil
		retB = nil
		for idx := range ids {
			if ids[idx] == InvalidEntity {
				continue
			} // Skip if its a hole

			if compA != nil {
				retA = &compA[idx]
			}
			if compB != nil {
				retB = &compB[idx]
			}
			lambda(ids[idx], retA, retB)
		}
	}
}

// Maps the lambda function across every entity which matched the specified filters. Components are split based on the number of OS threads available.
func (v *View2[A, B]) MapIdParallel(lambda func(id Id, a *A, b *B)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]

	var sliceB *componentList[B]

	// 1. Calculate work
	// 2. Calculate number of threads to execute with
	// 3. Greedy divide work among N threads
	// 4. Execute for each in its own goroutine

	// 1. Calculate work
	totalWork := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		// Each id represents an entity that holds the requested component(s)
		// Each hole represents a deleted entity that used to hold the requested component(s)
		totalWork += len(lookup.id) // - len(lookup.holes)
	}

	// 2. Calculate number of threads to execute with
	numThreads := runtime.NumCPU()
	var waitGroup sync.WaitGroup

	type workItem struct {
		ids []Id

		compA []A

		compB []B
	}
	workChannel := make(chan workItem)

	for i := 0; i < numThreads; i++ {
		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			for {
				work, ok := <-workChannel
				if !ok {
					return
				}

				var retA *A
				var retB *B
				for idx := range work.ids {
					if work.ids[idx] == InvalidEntity {
						continue
					} // Skip if its a hole

					if work.compA != nil {
						retA = &work.compA[idx]
					}
					if work.compB != nil {
						retB = &work.compB[idx]
					}
					lambda(work.ids[idx], retA, retB)
				}
			}
		}()
	}

	// 3. Greedy divide work among N threads
	// Simple algorithm:
	// a. Find an evenly balanced distribution per thread
	// b. Generate all work until it gets consumed
	workPerThread := totalWork / numThreads

	// Generate

	var compA []A

	var compB []B

	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		ids := lookup.id

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}

		// workPerformed := 0

		start := 0
		end := 0
		numWorkItems := (len(ids) / workPerThread) + 1
		actualWorkPerThread := (len(ids) / numWorkItems) + 1
		for i := 0; i < numWorkItems; i++ {
			start = i * actualWorkPerThread
			end = (i + 1) * actualWorkPerThread
			if end > len(ids) {
				end = len(ids)
			}

			// workPerformed += len(ids[start:end])
			workChannel <- workItem{
				ids: ids[start:end],

				compA: compA[start:end],

				compB: compB[start:end],
			}
		}

		// if workPerformed != len(ids) {
		// 	panic("wrong")
		// }
	}

	close(workChannel)
	waitGroup.Wait()
}

// Deprecated: This API is a tentative alternative way to map
func (v *View2[A, B]) MapSlices(lambda func(id []Id, a []A, b []B)) {
	v.filter.regenerate(v.world)

	id := make([][]Id, 0)

	sliceListA := make([][]A, 0)
	sliceListB := make([][]B, 0)

	for _, archId := range v.filter.archIds {

		sliceA, ok := v.storageA.slice.Get(archId)
		if !ok {
			continue
		}
		sliceB, ok := v.storageB.slice.Get(archId)
		if !ok {
			continue
		}

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }

		id = append(id, lookup.id)

		sliceListA = append(sliceListA, sliceA.comp)
		sliceListB = append(sliceListB, sliceB.comp)
	}

	for idx := range id {
		lambda(id[idx],
			sliceListA[idx], sliceListB[idx],
		)
	}
}

// --------------------------------------------------------------------------------
// - View 3
// --------------------------------------------------------------------------------

// Represents a view of data in a specific world. Provides access to the components specified in the generic block
type View3[A, B, C any] struct {
	world  *World
	filter filterList

	storageA *componentStorage[A]
	storageB *componentStorage[B]
	storageC *componentStorage[C]
}

// implement the intializer interface so that it can be automatically created and injected into systems
func (v *View3[A, B, C]) initialize(world *World) any {
	// TODO: filters need to be a part of the query type
	return Query3[A, B, C](world)
}

// Creates a View for the specified world with the specified component filters.
func Query3[A, B, C any](world *World, filters ...Filter) *View3[A, B, C] {

	storageA := getStorage[A](world.engine)
	storageB := getStorage[B](world.engine)
	storageC := getStorage[C](world.engine)

	var AA A
	var BB B
	var CC C

	comps := []CompId{

		name(AA),
		name(BB),
		name(CC),
	}
	filterList := newFilterList(comps, filters...)
	filterList.regenerate(world)

	v := &View3[A, B, C]{
		world:  world,
		filter: filterList,

		storageA: storageA,
		storageB: storageB,
		storageC: storageC,
	}
	return v
}

// Reads a pointer to the underlying component at the specified id.
// Read will return even if the specified id doesn't match the filter list
// Read will return the value if it exists, else returns nil.
// If you execute any ecs.Write(...) or ecs.Delete(...) this pointer may become invalid.
func (v *View3[A, B, C]) Read(id Id) (*A, *B, *C) {
	if id == InvalidEntity {
		return nil, nil, nil
	}

	loc, ok := v.world.arch.Get(id)
	if !ok {
		return nil, nil, nil
	}
	lookup := v.world.engine.lookup[loc.archId]
	if lookup == nil {
		panic("LookupList is missing!")
	}
	// index, ok := lookup.index.Get(id)
	// if !ok {
	// 	return nil, nil, nil
	// }
	index := int(loc.index)

	var retA *A
	var retB *B
	var retC *C

	sliceA, ok := v.storageA.slice.Get(loc.archId)
	if ok {
		retA = &sliceA.comp[index]
	}
	sliceB, ok := v.storageB.slice.Get(loc.archId)
	if ok {
		retB = &sliceB.comp[index]
	}
	sliceC, ok := v.storageC.slice.Get(loc.archId)
	if ok {
		retC = &sliceC.comp[index]
	}

	return retA, retB, retC
}

// Counts the number of entities that match this query
func (v *View3[A, B, C]) Count() int {
	v.filter.regenerate(v.world)

	total := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		total += lookup.Len()
	}
	return total
}

// Maps the lambda function across every entity which matched the specified filters.
func (v *View3[A, B, C]) MapId(lambda func(id Id, a *A, b *B, c *C)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]
	var compA []A
	var retA *A

	var sliceB *componentList[B]
	var compB []B
	var retB *B

	var sliceC *componentList[C]
	var compC []C
	var retC *C

	for _, archId := range v.filter.archIds {

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }
		ids := lookup.id

		// TODO - this flattened version causes a mild performance hit. But the other one combinatorially explodes. I also cant get BCE to work with it. See option 2 for higher performance.

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}

		retA = nil
		retB = nil
		retC = nil
		for idx := range ids {
			if ids[idx] == InvalidEntity {
				continue
			} // Skip if its a hole

			if compA != nil {
				retA = &compA[idx]
			}
			if compB != nil {
				retB = &compB[idx]
			}
			if compC != nil {
				retC = &compC[idx]
			}
			lambda(ids[idx], retA, retB, retC)
		}
	}
}

// Maps the lambda function across every entity which matched the specified filters. Components are split based on the number of OS threads available.
func (v *View3[A, B, C]) MapIdParallel(lambda func(id Id, a *A, b *B, c *C)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]

	var sliceB *componentList[B]

	var sliceC *componentList[C]

	// 1. Calculate work
	// 2. Calculate number of threads to execute with
	// 3. Greedy divide work among N threads
	// 4. Execute for each in its own goroutine

	// 1. Calculate work
	totalWork := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		// Each id represents an entity that holds the requested component(s)
		// Each hole represents a deleted entity that used to hold the requested component(s)
		totalWork += len(lookup.id) // - len(lookup.holes)
	}

	// 2. Calculate number of threads to execute with
	numThreads := runtime.NumCPU()
	var waitGroup sync.WaitGroup

	type workItem struct {
		ids []Id

		compA []A

		compB []B

		compC []C
	}
	workChannel := make(chan workItem)

	for i := 0; i < numThreads; i++ {
		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			for {
				work, ok := <-workChannel
				if !ok {
					return
				}

				var retA *A
				var retB *B
				var retC *C
				for idx := range work.ids {
					if work.ids[idx] == InvalidEntity {
						continue
					} // Skip if its a hole

					if work.compA != nil {
						retA = &work.compA[idx]
					}
					if work.compB != nil {
						retB = &work.compB[idx]
					}
					if work.compC != nil {
						retC = &work.compC[idx]
					}
					lambda(work.ids[idx], retA, retB, retC)
				}
			}
		}()
	}

	// 3. Greedy divide work among N threads
	// Simple algorithm:
	// a. Find an evenly balanced distribution per thread
	// b. Generate all work until it gets consumed
	workPerThread := totalWork / numThreads

	// Generate

	var compA []A

	var compB []B

	var compC []C

	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		ids := lookup.id

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}

		// workPerformed := 0

		start := 0
		end := 0
		numWorkItems := (len(ids) / workPerThread) + 1
		actualWorkPerThread := (len(ids) / numWorkItems) + 1
		for i := 0; i < numWorkItems; i++ {
			start = i * actualWorkPerThread
			end = (i + 1) * actualWorkPerThread
			if end > len(ids) {
				end = len(ids)
			}

			// workPerformed += len(ids[start:end])
			workChannel <- workItem{
				ids: ids[start:end],

				compA: compA[start:end],

				compB: compB[start:end],

				compC: compC[start:end],
			}
		}

		// if workPerformed != len(ids) {
		// 	panic("wrong")
		// }
	}

	close(workChannel)
	waitGroup.Wait()
}

// Deprecated: This API is a tentative alternative way to map
func (v *View3[A, B, C]) MapSlices(lambda func(id []Id, a []A, b []B, c []C)) {
	v.filter.regenerate(v.world)

	id := make([][]Id, 0)

	sliceListA := make([][]A, 0)
	sliceListB := make([][]B, 0)
	sliceListC := make([][]C, 0)

	for _, archId := range v.filter.archIds {

		sliceA, ok := v.storageA.slice.Get(archId)
		if !ok {
			continue
		}
		sliceB, ok := v.storageB.slice.Get(archId)
		if !ok {
			continue
		}
		sliceC, ok := v.storageC.slice.Get(archId)
		if !ok {
			continue
		}

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }

		id = append(id, lookup.id)

		sliceListA = append(sliceListA, sliceA.comp)
		sliceListB = append(sliceListB, sliceB.comp)
		sliceListC = append(sliceListC, sliceC.comp)
	}

	for idx := range id {
		lambda(id[idx],
			sliceListA[idx], sliceListB[idx], sliceListC[idx],
		)
	}
}

// --------------------------------------------------------------------------------
// - View 4
// --------------------------------------------------------------------------------

// Represents a view of data in a specific world. Provides access to the components specified in the generic block
type View4[A, B, C, D any] struct {
	world  *World
	filter filterList

	storageA *componentStorage[A]
	storageB *componentStorage[B]
	storageC *componentStorage[C]
	storageD *componentStorage[D]
}

// implement the intializer interface so that it can be automatically created and injected into systems
func (v *View4[A, B, C, D]) initialize(world *World) any {
	// TODO: filters need to be a part of the query type
	return Query4[A, B, C, D](world)
}

// Creates a View for the specified world with the specified component filters.
func Query4[A, B, C, D any](world *World, filters ...Filter) *View4[A, B, C, D] {

	storageA := getStorage[A](world.engine)
	storageB := getStorage[B](world.engine)
	storageC := getStorage[C](world.engine)
	storageD := getStorage[D](world.engine)

	var AA A
	var BB B
	var CC C
	var DD D

	comps := []CompId{

		name(AA),
		name(BB),
		name(CC),
		name(DD),
	}
	filterList := newFilterList(comps, filters...)
	filterList.regenerate(world)

	v := &View4[A, B, C, D]{
		world:  world,
		filter: filterList,

		storageA: storageA,
		storageB: storageB,
		storageC: storageC,
		storageD: storageD,
	}
	return v
}

// Reads a pointer to the underlying component at the specified id.
// Read will return even if the specified id doesn't match the filter list
// Read will return the value if it exists, else returns nil.
// If you execute any ecs.Write(...) or ecs.Delete(...) this pointer may become invalid.
func (v *View4[A, B, C, D]) Read(id Id) (*A, *B, *C, *D) {
	if id == InvalidEntity {
		return nil, nil, nil, nil
	}

	loc, ok := v.world.arch.Get(id)
	if !ok {
		return nil, nil, nil, nil
	}
	lookup := v.world.engine.lookup[loc.archId]
	if lookup == nil {
		panic("LookupList is missing!")
	}
	// index, ok := lookup.index.Get(id)
	// if !ok {
	// 	return nil, nil, nil, nil
	// }
	index := int(loc.index)

	var retA *A
	var retB *B
	var retC *C
	var retD *D

	sliceA, ok := v.storageA.slice.Get(loc.archId)
	if ok {
		retA = &sliceA.comp[index]
	}
	sliceB, ok := v.storageB.slice.Get(loc.archId)
	if ok {
		retB = &sliceB.comp[index]
	}
	sliceC, ok := v.storageC.slice.Get(loc.archId)
	if ok {
		retC = &sliceC.comp[index]
	}
	sliceD, ok := v.storageD.slice.Get(loc.archId)
	if ok {
		retD = &sliceD.comp[index]
	}

	return retA, retB, retC, retD
}

// Counts the number of entities that match this query
func (v *View4[A, B, C, D]) Count() int {
	v.filter.regenerate(v.world)

	total := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		total += lookup.Len()
	}
	return total
}

// Maps the lambda function across every entity which matched the specified filters.
func (v *View4[A, B, C, D]) MapId(lambda func(id Id, a *A, b *B, c *C, d *D)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]
	var compA []A
	var retA *A

	var sliceB *componentList[B]
	var compB []B
	var retB *B

	var sliceC *componentList[C]
	var compC []C
	var retC *C

	var sliceD *componentList[D]
	var compD []D
	var retD *D

	for _, archId := range v.filter.archIds {

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }
		ids := lookup.id

		// TODO - this flattened version causes a mild performance hit. But the other one combinatorially explodes. I also cant get BCE to work with it. See option 2 for higher performance.

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}

		retA = nil
		retB = nil
		retC = nil
		retD = nil
		for idx := range ids {
			if ids[idx] == InvalidEntity {
				continue
			} // Skip if its a hole

			if compA != nil {
				retA = &compA[idx]
			}
			if compB != nil {
				retB = &compB[idx]
			}
			if compC != nil {
				retC = &compC[idx]
			}
			if compD != nil {
				retD = &compD[idx]
			}
			lambda(ids[idx], retA, retB, retC, retD)
		}
	}
}

// Maps the lambda function across every entity which matched the specified filters. Components are split based on the number of OS threads available.
func (v *View4[A, B, C, D]) MapIdParallel(lambda func(id Id, a *A, b *B, c *C, d *D)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]

	var sliceB *componentList[B]

	var sliceC *componentList[C]

	var sliceD *componentList[D]

	// 1. Calculate work
	// 2. Calculate number of threads to execute with
	// 3. Greedy divide work among N threads
	// 4. Execute for each in its own goroutine

	// 1. Calculate work
	totalWork := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		// Each id represents an entity that holds the requested component(s)
		// Each hole represents a deleted entity that used to hold the requested component(s)
		totalWork += len(lookup.id) // - len(lookup.holes)
	}

	// 2. Calculate number of threads to execute with
	numThreads := runtime.NumCPU()
	var waitGroup sync.WaitGroup

	type workItem struct {
		ids []Id

		compA []A

		compB []B

		compC []C

		compD []D
	}
	workChannel := make(chan workItem)

	for i := 0; i < numThreads; i++ {
		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			for {
				work, ok := <-workChannel
				if !ok {
					return
				}

				var retA *A
				var retB *B
				var retC *C
				var retD *D
				for idx := range work.ids {
					if work.ids[idx] == InvalidEntity {
						continue
					} // Skip if its a hole

					if work.compA != nil {
						retA = &work.compA[idx]
					}
					if work.compB != nil {
						retB = &work.compB[idx]
					}
					if work.compC != nil {
						retC = &work.compC[idx]
					}
					if work.compD != nil {
						retD = &work.compD[idx]
					}
					lambda(work.ids[idx], retA, retB, retC, retD)
				}
			}
		}()
	}

	// 3. Greedy divide work among N threads
	// Simple algorithm:
	// a. Find an evenly balanced distribution per thread
	// b. Generate all work until it gets consumed
	workPerThread := totalWork / numThreads

	// Generate

	var compA []A

	var compB []B

	var compC []C

	var compD []D

	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		ids := lookup.id

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}

		// workPerformed := 0

		start := 0
		end := 0
		numWorkItems := (len(ids) / workPerThread) + 1
		actualWorkPerThread := (len(ids) / numWorkItems) + 1
		for i := 0; i < numWorkItems; i++ {
			start = i * actualWorkPerThread
			end = (i + 1) * actualWorkPerThread
			if end > len(ids) {
				end = len(ids)
			}

			// workPerformed += len(ids[start:end])
			workChannel <- workItem{
				ids: ids[start:end],

				compA: compA[start:end],

				compB: compB[start:end],

				compC: compC[start:end],

				compD: compD[start:end],
			}
		}

		// if workPerformed != len(ids) {
		// 	panic("wrong")
		// }
	}

	close(workChannel)
	waitGroup.Wait()
}

// Deprecated: This API is a tentative alternative way to map
func (v *View4[A, B, C, D]) MapSlices(lambda func(id []Id, a []A, b []B, c []C, d []D)) {
	v.filter.regenerate(v.world)

	id := make([][]Id, 0)

	sliceListA := make([][]A, 0)
	sliceListB := make([][]B, 0)
	sliceListC := make([][]C, 0)
	sliceListD := make([][]D, 0)

	for _, archId := range v.filter.archIds {

		sliceA, ok := v.storageA.slice.Get(archId)
		if !ok {
			continue
		}
		sliceB, ok := v.storageB.slice.Get(archId)
		if !ok {
			continue
		}
		sliceC, ok := v.storageC.slice.Get(archId)
		if !ok {
			continue
		}
		sliceD, ok := v.storageD.slice.Get(archId)
		if !ok {
			continue
		}

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }

		id = append(id, lookup.id)

		sliceListA = append(sliceListA, sliceA.comp)
		sliceListB = append(sliceListB, sliceB.comp)
		sliceListC = append(sliceListC, sliceC.comp)
		sliceListD = append(sliceListD, sliceD.comp)
	}

	for idx := range id {
		lambda(id[idx],
			sliceListA[idx], sliceListB[idx], sliceListC[idx], sliceListD[idx],
		)
	}
}

// --------------------------------------------------------------------------------
// - View 5
// --------------------------------------------------------------------------------

// Represents a view of data in a specific world. Provides access to the components specified in the generic block
type View5[A, B, C, D, E any] struct {
	world  *World
	filter filterList

	storageA *componentStorage[A]
	storageB *componentStorage[B]
	storageC *componentStorage[C]
	storageD *componentStorage[D]
	storageE *componentStorage[E]
}

// implement the intializer interface so that it can be automatically created and injected into systems
func (v *View5[A, B, C, D, E]) initialize(world *World) any {
	// TODO: filters need to be a part of the query type
	return Query5[A, B, C, D, E](world)
}

// Creates a View for the specified world with the specified component filters.
func Query5[A, B, C, D, E any](world *World, filters ...Filter) *View5[A, B, C, D, E] {

	storageA := getStorage[A](world.engine)
	storageB := getStorage[B](world.engine)
	storageC := getStorage[C](world.engine)
	storageD := getStorage[D](world.engine)
	storageE := getStorage[E](world.engine)

	var AA A
	var BB B
	var CC C
	var DD D
	var EE E

	comps := []CompId{

		name(AA),
		name(BB),
		name(CC),
		name(DD),
		name(EE),
	}
	filterList := newFilterList(comps, filters...)
	filterList.regenerate(world)

	v := &View5[A, B, C, D, E]{
		world:  world,
		filter: filterList,

		storageA: storageA,
		storageB: storageB,
		storageC: storageC,
		storageD: storageD,
		storageE: storageE,
	}
	return v
}

// Reads a pointer to the underlying component at the specified id.
// Read will return even if the specified id doesn't match the filter list
// Read will return the value if it exists, else returns nil.
// If you execute any ecs.Write(...) or ecs.Delete(...) this pointer may become invalid.
func (v *View5[A, B, C, D, E]) Read(id Id) (*A, *B, *C, *D, *E) {
	if id == InvalidEntity {
		return nil, nil, nil, nil, nil
	}

	loc, ok := v.world.arch.Get(id)
	if !ok {
		return nil, nil, nil, nil, nil
	}
	lookup := v.world.engine.lookup[loc.archId]
	if lookup == nil {
		panic("LookupList is missing!")
	}
	// index, ok := lookup.index.Get(id)
	// if !ok {
	// 	return nil, nil, nil, nil, nil
	// }
	index := int(loc.index)

	var retA *A
	var retB *B
	var retC *C
	var retD *D
	var retE *E

	sliceA, ok := v.storageA.slice.Get(loc.archId)
	if ok {
		retA = &sliceA.comp[index]
	}
	sliceB, ok := v.storageB.slice.Get(loc.archId)
	if ok {
		retB = &sliceB.comp[index]
	}
	sliceC, ok := v.storageC.slice.Get(loc.archId)
	if ok {
		retC = &sliceC.comp[index]
	}
	sliceD, ok := v.storageD.slice.Get(loc.archId)
	if ok {
		retD = &sliceD.comp[index]
	}
	sliceE, ok := v.storageE.slice.Get(loc.archId)
	if ok {
		retE = &sliceE.comp[index]
	}

	return retA, retB, retC, retD, retE
}

// Counts the number of entities that match this query
func (v *View5[A, B, C, D, E]) Count() int {
	v.filter.regenerate(v.world)

	total := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		total += lookup.Len()
	}
	return total
}

// Maps the lambda function across every entity which matched the specified filters.
func (v *View5[A, B, C, D, E]) MapId(lambda func(id Id, a *A, b *B, c *C, d *D, e *E)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]
	var compA []A
	var retA *A

	var sliceB *componentList[B]
	var compB []B
	var retB *B

	var sliceC *componentList[C]
	var compC []C
	var retC *C

	var sliceD *componentList[D]
	var compD []D
	var retD *D

	var sliceE *componentList[E]
	var compE []E
	var retE *E

	for _, archId := range v.filter.archIds {

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }
		ids := lookup.id

		// TODO - this flattened version causes a mild performance hit. But the other one combinatorially explodes. I also cant get BCE to work with it. See option 2 for higher performance.

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}

		retA = nil
		retB = nil
		retC = nil
		retD = nil
		retE = nil
		for idx := range ids {
			if ids[idx] == InvalidEntity {
				continue
			} // Skip if its a hole

			if compA != nil {
				retA = &compA[idx]
			}
			if compB != nil {
				retB = &compB[idx]
			}
			if compC != nil {
				retC = &compC[idx]
			}
			if compD != nil {
				retD = &compD[idx]
			}
			if compE != nil {
				retE = &compE[idx]
			}
			lambda(ids[idx], retA, retB, retC, retD, retE)
		}
	}
}

// Maps the lambda function across every entity which matched the specified filters. Components are split based on the number of OS threads available.
func (v *View5[A, B, C, D, E]) MapIdParallel(lambda func(id Id, a *A, b *B, c *C, d *D, e *E)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]

	var sliceB *componentList[B]

	var sliceC *componentList[C]

	var sliceD *componentList[D]

	var sliceE *componentList[E]

	// 1. Calculate work
	// 2. Calculate number of threads to execute with
	// 3. Greedy divide work among N threads
	// 4. Execute for each in its own goroutine

	// 1. Calculate work
	totalWork := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		// Each id represents an entity that holds the requested component(s)
		// Each hole represents a deleted entity that used to hold the requested component(s)
		totalWork += len(lookup.id) // - len(lookup.holes)
	}

	// 2. Calculate number of threads to execute with
	numThreads := runtime.NumCPU()
	var waitGroup sync.WaitGroup

	type workItem struct {
		ids []Id

		compA []A

		compB []B

		compC []C

		compD []D

		compE []E
	}
	workChannel := make(chan workItem)

	for i := 0; i < numThreads; i++ {
		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			for {
				work, ok := <-workChannel
				if !ok {
					return
				}

				var retA *A
				var retB *B
				var retC *C
				var retD *D
				var retE *E
				for idx := range work.ids {
					if work.ids[idx] == InvalidEntity {
						continue
					} // Skip if its a hole

					if work.compA != nil {
						retA = &work.compA[idx]
					}
					if work.compB != nil {
						retB = &work.compB[idx]
					}
					if work.compC != nil {
						retC = &work.compC[idx]
					}
					if work.compD != nil {
						retD = &work.compD[idx]
					}
					if work.compE != nil {
						retE = &work.compE[idx]
					}
					lambda(work.ids[idx], retA, retB, retC, retD, retE)
				}
			}
		}()
	}

	// 3. Greedy divide work among N threads
	// Simple algorithm:
	// a. Find an evenly balanced distribution per thread
	// b. Generate all work until it gets consumed
	workPerThread := totalWork / numThreads

	// Generate

	var compA []A

	var compB []B

	var compC []C

	var compD []D

	var compE []E

	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		ids := lookup.id

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}

		// workPerformed := 0

		start := 0
		end := 0
		numWorkItems := (len(ids) / workPerThread) + 1
		actualWorkPerThread := (len(ids) / numWorkItems) + 1
		for i := 0; i < numWorkItems; i++ {
			start = i * actualWorkPerThread
			end = (i + 1) * actualWorkPerThread
			if end > len(ids) {
				end = len(ids)
			}

			// workPerformed += len(ids[start:end])
			workChannel <- workItem{
				ids: ids[start:end],

				compA: compA[start:end],

				compB: compB[start:end],

				compC: compC[start:end],

				compD: compD[start:end],

				compE: compE[start:end],
			}
		}

		// if workPerformed != len(ids) {
		// 	panic("wrong")
		// }
	}

	close(workChannel)
	waitGroup.Wait()
}

// Deprecated: This API is a tentative alternative way to map
func (v *View5[A, B, C, D, E]) MapSlices(lambda func(id []Id, a []A, b []B, c []C, d []D, e []E)) {
	v.filter.regenerate(v.world)

	id := make([][]Id, 0)

	sliceListA := make([][]A, 0)
	sliceListB := make([][]B, 0)
	sliceListC := make([][]C, 0)
	sliceListD := make([][]D, 0)
	sliceListE := make([][]E, 0)

	for _, archId := range v.filter.archIds {

		sliceA, ok := v.storageA.slice.Get(archId)
		if !ok {
			continue
		}
		sliceB, ok := v.storageB.slice.Get(archId)
		if !ok {
			continue
		}
		sliceC, ok := v.storageC.slice.Get(archId)
		if !ok {
			continue
		}
		sliceD, ok := v.storageD.slice.Get(archId)
		if !ok {
			continue
		}
		sliceE, ok := v.storageE.slice.Get(archId)
		if !ok {
			continue
		}

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }

		id = append(id, lookup.id)

		sliceListA = append(sliceListA, sliceA.comp)
		sliceListB = append(sliceListB, sliceB.comp)
		sliceListC = append(sliceListC, sliceC.comp)
		sliceListD = append(sliceListD, sliceD.comp)
		sliceListE = append(sliceListE, sliceE.comp)
	}

	for idx := range id {
		lambda(id[idx],
			sliceListA[idx], sliceListB[idx], sliceListC[idx], sliceListD[idx], sliceListE[idx],
		)
	}
}

// --------------------------------------------------------------------------------
// - View 6
// --------------------------------------------------------------------------------

// Represents a view of data in a specific world. Provides access to the components specified in the generic block
type View6[A, B, C, D, E, F any] struct {
	world  *World
	filter filterList

	storageA *componentStorage[A]
	storageB *componentStorage[B]
	storageC *componentStorage[C]
	storageD *componentStorage[D]
	storageE *componentStorage[E]
	storageF *componentStorage[F]
}

// implement the intializer interface so that it can be automatically created and injected into systems
func (v *View6[A, B, C, D, E, F]) initialize(world *World) any {
	// TODO: filters need to be a part of the query type
	return Query6[A, B, C, D, E, F](world)
}

// Creates a View for the specified world with the specified component filters.
func Query6[A, B, C, D, E, F any](world *World, filters ...Filter) *View6[A, B, C, D, E, F] {

	storageA := getStorage[A](world.engine)
	storageB := getStorage[B](world.engine)
	storageC := getStorage[C](world.engine)
	storageD := getStorage[D](world.engine)
	storageE := getStorage[E](world.engine)
	storageF := getStorage[F](world.engine)

	var AA A
	var BB B
	var CC C
	var DD D
	var EE E
	var FF F

	comps := []CompId{

		name(AA),
		name(BB),
		name(CC),
		name(DD),
		name(EE),
		name(FF),
	}
	filterList := newFilterList(comps, filters...)
	filterList.regenerate(world)

	v := &View6[A, B, C, D, E, F]{
		world:  world,
		filter: filterList,

		storageA: storageA,
		storageB: storageB,
		storageC: storageC,
		storageD: storageD,
		storageE: storageE,
		storageF: storageF,
	}
	return v
}

// Reads a pointer to the underlying component at the specified id.
// Read will return even if the specified id doesn't match the filter list
// Read will return the value if it exists, else returns nil.
// If you execute any ecs.Write(...) or ecs.Delete(...) this pointer may become invalid.
func (v *View6[A, B, C, D, E, F]) Read(id Id) (*A, *B, *C, *D, *E, *F) {
	if id == InvalidEntity {
		return nil, nil, nil, nil, nil, nil
	}

	loc, ok := v.world.arch.Get(id)
	if !ok {
		return nil, nil, nil, nil, nil, nil
	}
	lookup := v.world.engine.lookup[loc.archId]
	if lookup == nil {
		panic("LookupList is missing!")
	}
	// index, ok := lookup.index.Get(id)
	// if !ok {
	// 	return nil, nil, nil, nil, nil, nil
	// }
	index := int(loc.index)

	var retA *A
	var retB *B
	var retC *C
	var retD *D
	var retE *E
	var retF *F

	sliceA, ok := v.storageA.slice.Get(loc.archId)
	if ok {
		retA = &sliceA.comp[index]
	}
	sliceB, ok := v.storageB.slice.Get(loc.archId)
	if ok {
		retB = &sliceB.comp[index]
	}
	sliceC, ok := v.storageC.slice.Get(loc.archId)
	if ok {
		retC = &sliceC.comp[index]
	}
	sliceD, ok := v.storageD.slice.Get(loc.archId)
	if ok {
		retD = &sliceD.comp[index]
	}
	sliceE, ok := v.storageE.slice.Get(loc.archId)
	if ok {
		retE = &sliceE.comp[index]
	}
	sliceF, ok := v.storageF.slice.Get(loc.archId)
	if ok {
		retF = &sliceF.comp[index]
	}

	return retA, retB, retC, retD, retE, retF
}

// Counts the number of entities that match this query
func (v *View6[A, B, C, D, E, F]) Count() int {
	v.filter.regenerate(v.world)

	total := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		total += lookup.Len()
	}
	return total
}

// Maps the lambda function across every entity which matched the specified filters.
func (v *View6[A, B, C, D, E, F]) MapId(lambda func(id Id, a *A, b *B, c *C, d *D, e *E, f *F)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]
	var compA []A
	var retA *A

	var sliceB *componentList[B]
	var compB []B
	var retB *B

	var sliceC *componentList[C]
	var compC []C
	var retC *C

	var sliceD *componentList[D]
	var compD []D
	var retD *D

	var sliceE *componentList[E]
	var compE []E
	var retE *E

	var sliceF *componentList[F]
	var compF []F
	var retF *F

	for _, archId := range v.filter.archIds {

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)
		sliceF, _ = v.storageF.slice.Get(archId)

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }
		ids := lookup.id

		// TODO - this flattened version causes a mild performance hit. But the other one combinatorially explodes. I also cant get BCE to work with it. See option 2 for higher performance.

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}
		compF = nil
		if sliceF != nil {
			compF = sliceF.comp
		}

		retA = nil
		retB = nil
		retC = nil
		retD = nil
		retE = nil
		retF = nil
		for idx := range ids {
			if ids[idx] == InvalidEntity {
				continue
			} // Skip if its a hole

			if compA != nil {
				retA = &compA[idx]
			}
			if compB != nil {
				retB = &compB[idx]
			}
			if compC != nil {
				retC = &compC[idx]
			}
			if compD != nil {
				retD = &compD[idx]
			}
			if compE != nil {
				retE = &compE[idx]
			}
			if compF != nil {
				retF = &compF[idx]
			}
			lambda(ids[idx], retA, retB, retC, retD, retE, retF)
		}
	}
}

// Maps the lambda function across every entity which matched the specified filters. Components are split based on the number of OS threads available.
func (v *View6[A, B, C, D, E, F]) MapIdParallel(lambda func(id Id, a *A, b *B, c *C, d *D, e *E, f *F)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]

	var sliceB *componentList[B]

	var sliceC *componentList[C]

	var sliceD *componentList[D]

	var sliceE *componentList[E]

	var sliceF *componentList[F]

	// 1. Calculate work
	// 2. Calculate number of threads to execute with
	// 3. Greedy divide work among N threads
	// 4. Execute for each in its own goroutine

	// 1. Calculate work
	totalWork := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		// Each id represents an entity that holds the requested component(s)
		// Each hole represents a deleted entity that used to hold the requested component(s)
		totalWork += len(lookup.id) // - len(lookup.holes)
	}

	// 2. Calculate number of threads to execute with
	numThreads := runtime.NumCPU()
	var waitGroup sync.WaitGroup

	type workItem struct {
		ids []Id

		compA []A

		compB []B

		compC []C

		compD []D

		compE []E

		compF []F
	}
	workChannel := make(chan workItem)

	for i := 0; i < numThreads; i++ {
		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			for {
				work, ok := <-workChannel
				if !ok {
					return
				}

				var retA *A
				var retB *B
				var retC *C
				var retD *D
				var retE *E
				var retF *F
				for idx := range work.ids {
					if work.ids[idx] == InvalidEntity {
						continue
					} // Skip if its a hole

					if work.compA != nil {
						retA = &work.compA[idx]
					}
					if work.compB != nil {
						retB = &work.compB[idx]
					}
					if work.compC != nil {
						retC = &work.compC[idx]
					}
					if work.compD != nil {
						retD = &work.compD[idx]
					}
					if work.compE != nil {
						retE = &work.compE[idx]
					}
					if work.compF != nil {
						retF = &work.compF[idx]
					}
					lambda(work.ids[idx], retA, retB, retC, retD, retE, retF)
				}
			}
		}()
	}

	// 3. Greedy divide work among N threads
	// Simple algorithm:
	// a. Find an evenly balanced distribution per thread
	// b. Generate all work until it gets consumed
	workPerThread := totalWork / numThreads

	// Generate

	var compA []A

	var compB []B

	var compC []C

	var compD []D

	var compE []E

	var compF []F

	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		ids := lookup.id

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)
		sliceF, _ = v.storageF.slice.Get(archId)

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}
		compF = nil
		if sliceF != nil {
			compF = sliceF.comp
		}

		// workPerformed := 0

		start := 0
		end := 0
		numWorkItems := (len(ids) / workPerThread) + 1
		actualWorkPerThread := (len(ids) / numWorkItems) + 1
		for i := 0; i < numWorkItems; i++ {
			start = i * actualWorkPerThread
			end = (i + 1) * actualWorkPerThread
			if end > len(ids) {
				end = len(ids)
			}

			// workPerformed += len(ids[start:end])
			workChannel <- workItem{
				ids: ids[start:end],

				compA: compA[start:end],

				compB: compB[start:end],

				compC: compC[start:end],

				compD: compD[start:end],

				compE: compE[start:end],

				compF: compF[start:end],
			}
		}

		// if workPerformed != len(ids) {
		// 	panic("wrong")
		// }
	}

	close(workChannel)
	waitGroup.Wait()
}

// Deprecated: This API is a tentative alternative way to map
func (v *View6[A, B, C, D, E, F]) MapSlices(lambda func(id []Id, a []A, b []B, c []C, d []D, e []E, f []F)) {
	v.filter.regenerate(v.world)

	id := make([][]Id, 0)

	sliceListA := make([][]A, 0)
	sliceListB := make([][]B, 0)
	sliceListC := make([][]C, 0)
	sliceListD := make([][]D, 0)
	sliceListE := make([][]E, 0)
	sliceListF := make([][]F, 0)

	for _, archId := range v.filter.archIds {

		sliceA, ok := v.storageA.slice.Get(archId)
		if !ok {
			continue
		}
		sliceB, ok := v.storageB.slice.Get(archId)
		if !ok {
			continue
		}
		sliceC, ok := v.storageC.slice.Get(archId)
		if !ok {
			continue
		}
		sliceD, ok := v.storageD.slice.Get(archId)
		if !ok {
			continue
		}
		sliceE, ok := v.storageE.slice.Get(archId)
		if !ok {
			continue
		}
		sliceF, ok := v.storageF.slice.Get(archId)
		if !ok {
			continue
		}

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }

		id = append(id, lookup.id)

		sliceListA = append(sliceListA, sliceA.comp)
		sliceListB = append(sliceListB, sliceB.comp)
		sliceListC = append(sliceListC, sliceC.comp)
		sliceListD = append(sliceListD, sliceD.comp)
		sliceListE = append(sliceListE, sliceE.comp)
		sliceListF = append(sliceListF, sliceF.comp)
	}

	for idx := range id {
		lambda(id[idx],
			sliceListA[idx], sliceListB[idx], sliceListC[idx], sliceListD[idx], sliceListE[idx], sliceListF[idx],
		)
	}
}

// --------------------------------------------------------------------------------
// - View 7
// --------------------------------------------------------------------------------

// Represents a view of data in a specific world. Provides access to the components specified in the generic block
type View7[A, B, C, D, E, F, G any] struct {
	world  *World
	filter filterList

	storageA *componentStorage[A]
	storageB *componentStorage[B]
	storageC *componentStorage[C]
	storageD *componentStorage[D]
	storageE *componentStorage[E]
	storageF *componentStorage[F]
	storageG *componentStorage[G]
}

// implement the intializer interface so that it can be automatically created and injected into systems
func (v *View7[A, B, C, D, E, F, G]) initialize(world *World) any {
	// TODO: filters need to be a part of the query type
	return Query7[A, B, C, D, E, F, G](world)
}

// Creates a View for the specified world with the specified component filters.
func Query7[A, B, C, D, E, F, G any](world *World, filters ...Filter) *View7[A, B, C, D, E, F, G] {

	storageA := getStorage[A](world.engine)
	storageB := getStorage[B](world.engine)
	storageC := getStorage[C](world.engine)
	storageD := getStorage[D](world.engine)
	storageE := getStorage[E](world.engine)
	storageF := getStorage[F](world.engine)
	storageG := getStorage[G](world.engine)

	var AA A
	var BB B
	var CC C
	var DD D
	var EE E
	var FF F
	var GG G

	comps := []CompId{

		name(AA),
		name(BB),
		name(CC),
		name(DD),
		name(EE),
		name(FF),
		name(GG),
	}
	filterList := newFilterList(comps, filters...)
	filterList.regenerate(world)

	v := &View7[A, B, C, D, E, F, G]{
		world:  world,
		filter: filterList,

		storageA: storageA,
		storageB: storageB,
		storageC: storageC,
		storageD: storageD,
		storageE: storageE,
		storageF: storageF,
		storageG: storageG,
	}
	return v
}

// Reads a pointer to the underlying component at the specified id.
// Read will return even if the specified id doesn't match the filter list
// Read will return the value if it exists, else returns nil.
// If you execute any ecs.Write(...) or ecs.Delete(...) this pointer may become invalid.
func (v *View7[A, B, C, D, E, F, G]) Read(id Id) (*A, *B, *C, *D, *E, *F, *G) {
	if id == InvalidEntity {
		return nil, nil, nil, nil, nil, nil, nil
	}

	loc, ok := v.world.arch.Get(id)
	if !ok {
		return nil, nil, nil, nil, nil, nil, nil
	}
	lookup := v.world.engine.lookup[loc.archId]
	if lookup == nil {
		panic("LookupList is missing!")
	}
	// index, ok := lookup.index.Get(id)
	// if !ok {
	// 	return nil, nil, nil, nil, nil, nil, nil
	// }
	index := int(loc.index)

	var retA *A
	var retB *B
	var retC *C
	var retD *D
	var retE *E
	var retF *F
	var retG *G

	sliceA, ok := v.storageA.slice.Get(loc.archId)
	if ok {
		retA = &sliceA.comp[index]
	}
	sliceB, ok := v.storageB.slice.Get(loc.archId)
	if ok {
		retB = &sliceB.comp[index]
	}
	sliceC, ok := v.storageC.slice.Get(loc.archId)
	if ok {
		retC = &sliceC.comp[index]
	}
	sliceD, ok := v.storageD.slice.Get(loc.archId)
	if ok {
		retD = &sliceD.comp[index]
	}
	sliceE, ok := v.storageE.slice.Get(loc.archId)
	if ok {
		retE = &sliceE.comp[index]
	}
	sliceF, ok := v.storageF.slice.Get(loc.archId)
	if ok {
		retF = &sliceF.comp[index]
	}
	sliceG, ok := v.storageG.slice.Get(loc.archId)
	if ok {
		retG = &sliceG.comp[index]
	}

	return retA, retB, retC, retD, retE, retF, retG
}

// Counts the number of entities that match this query
func (v *View7[A, B, C, D, E, F, G]) Count() int {
	v.filter.regenerate(v.world)

	total := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		total += lookup.Len()
	}
	return total
}

// Maps the lambda function across every entity which matched the specified filters.
func (v *View7[A, B, C, D, E, F, G]) MapId(lambda func(id Id, a *A, b *B, c *C, d *D, e *E, f *F, g *G)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]
	var compA []A
	var retA *A

	var sliceB *componentList[B]
	var compB []B
	var retB *B

	var sliceC *componentList[C]
	var compC []C
	var retC *C

	var sliceD *componentList[D]
	var compD []D
	var retD *D

	var sliceE *componentList[E]
	var compE []E
	var retE *E

	var sliceF *componentList[F]
	var compF []F
	var retF *F

	var sliceG *componentList[G]
	var compG []G
	var retG *G

	for _, archId := range v.filter.archIds {

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)
		sliceF, _ = v.storageF.slice.Get(archId)
		sliceG, _ = v.storageG.slice.Get(archId)

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }
		ids := lookup.id

		// TODO - this flattened version causes a mild performance hit. But the other one combinatorially explodes. I also cant get BCE to work with it. See option 2 for higher performance.

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}
		compF = nil
		if sliceF != nil {
			compF = sliceF.comp
		}
		compG = nil
		if sliceG != nil {
			compG = sliceG.comp
		}

		retA = nil
		retB = nil
		retC = nil
		retD = nil
		retE = nil
		retF = nil
		retG = nil
		for idx := range ids {
			if ids[idx] == InvalidEntity {
				continue
			} // Skip if its a hole

			if compA != nil {
				retA = &compA[idx]
			}
			if compB != nil {
				retB = &compB[idx]
			}
			if compC != nil {
				retC = &compC[idx]
			}
			if compD != nil {
				retD = &compD[idx]
			}
			if compE != nil {
				retE = &compE[idx]
			}
			if compF != nil {
				retF = &compF[idx]
			}
			if compG != nil {
				retG = &compG[idx]
			}
			lambda(ids[idx], retA, retB, retC, retD, retE, retF, retG)
		}
	}
}

// Maps the lambda function across every entity which matched the specified filters. Components are split based on the number of OS threads available.
func (v *View7[A, B, C, D, E, F, G]) MapIdParallel(lambda func(id Id, a *A, b *B, c *C, d *D, e *E, f *F, g *G)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]

	var sliceB *componentList[B]

	var sliceC *componentList[C]

	var sliceD *componentList[D]

	var sliceE *componentList[E]

	var sliceF *componentList[F]

	var sliceG *componentList[G]

	// 1. Calculate work
	// 2. Calculate number of threads to execute with
	// 3. Greedy divide work among N threads
	// 4. Execute for each in its own goroutine

	// 1. Calculate work
	totalWork := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		// Each id represents an entity that holds the requested component(s)
		// Each hole represents a deleted entity that used to hold the requested component(s)
		totalWork += len(lookup.id) // - len(lookup.holes)
	}

	// 2. Calculate number of threads to execute with
	numThreads := runtime.NumCPU()
	var waitGroup sync.WaitGroup

	type workItem struct {
		ids []Id

		compA []A

		compB []B

		compC []C

		compD []D

		compE []E

		compF []F

		compG []G
	}
	workChannel := make(chan workItem)

	for i := 0; i < numThreads; i++ {
		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			for {
				work, ok := <-workChannel
				if !ok {
					return
				}

				var retA *A
				var retB *B
				var retC *C
				var retD *D
				var retE *E
				var retF *F
				var retG *G
				for idx := range work.ids {
					if work.ids[idx] == InvalidEntity {
						continue
					} // Skip if its a hole

					if work.compA != nil {
						retA = &work.compA[idx]
					}
					if work.compB != nil {
						retB = &work.compB[idx]
					}
					if work.compC != nil {
						retC = &work.compC[idx]
					}
					if work.compD != nil {
						retD = &work.compD[idx]
					}
					if work.compE != nil {
						retE = &work.compE[idx]
					}
					if work.compF != nil {
						retF = &work.compF[idx]
					}
					if work.compG != nil {
						retG = &work.compG[idx]
					}
					lambda(work.ids[idx], retA, retB, retC, retD, retE, retF, retG)
				}
			}
		}()
	}

	// 3. Greedy divide work among N threads
	// Simple algorithm:
	// a. Find an evenly balanced distribution per thread
	// b. Generate all work until it gets consumed
	workPerThread := totalWork / numThreads

	// Generate

	var compA []A

	var compB []B

	var compC []C

	var compD []D

	var compE []E

	var compF []F

	var compG []G

	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		ids := lookup.id

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)
		sliceF, _ = v.storageF.slice.Get(archId)
		sliceG, _ = v.storageG.slice.Get(archId)

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}
		compF = nil
		if sliceF != nil {
			compF = sliceF.comp
		}
		compG = nil
		if sliceG != nil {
			compG = sliceG.comp
		}

		// workPerformed := 0

		start := 0
		end := 0
		numWorkItems := (len(ids) / workPerThread) + 1
		actualWorkPerThread := (len(ids) / numWorkItems) + 1
		for i := 0; i < numWorkItems; i++ {
			start = i * actualWorkPerThread
			end = (i + 1) * actualWorkPerThread
			if end > len(ids) {
				end = len(ids)
			}

			// workPerformed += len(ids[start:end])
			workChannel <- workItem{
				ids: ids[start:end],

				compA: compA[start:end],

				compB: compB[start:end],

				compC: compC[start:end],

				compD: compD[start:end],

				compE: compE[start:end],

				compF: compF[start:end],

				compG: compG[start:end],
			}
		}

		// if workPerformed != len(ids) {
		// 	panic("wrong")
		// }
	}

	close(workChannel)
	waitGroup.Wait()
}

// Deprecated: This API is a tentative alternative way to map
func (v *View7[A, B, C, D, E, F, G]) MapSlices(lambda func(id []Id, a []A, b []B, c []C, d []D, e []E, f []F, g []G)) {
	v.filter.regenerate(v.world)

	id := make([][]Id, 0)

	sliceListA := make([][]A, 0)
	sliceListB := make([][]B, 0)
	sliceListC := make([][]C, 0)
	sliceListD := make([][]D, 0)
	sliceListE := make([][]E, 0)
	sliceListF := make([][]F, 0)
	sliceListG := make([][]G, 0)

	for _, archId := range v.filter.archIds {

		sliceA, ok := v.storageA.slice.Get(archId)
		if !ok {
			continue
		}
		sliceB, ok := v.storageB.slice.Get(archId)
		if !ok {
			continue
		}
		sliceC, ok := v.storageC.slice.Get(archId)
		if !ok {
			continue
		}
		sliceD, ok := v.storageD.slice.Get(archId)
		if !ok {
			continue
		}
		sliceE, ok := v.storageE.slice.Get(archId)
		if !ok {
			continue
		}
		sliceF, ok := v.storageF.slice.Get(archId)
		if !ok {
			continue
		}
		sliceG, ok := v.storageG.slice.Get(archId)
		if !ok {
			continue
		}

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }

		id = append(id, lookup.id)

		sliceListA = append(sliceListA, sliceA.comp)
		sliceListB = append(sliceListB, sliceB.comp)
		sliceListC = append(sliceListC, sliceC.comp)
		sliceListD = append(sliceListD, sliceD.comp)
		sliceListE = append(sliceListE, sliceE.comp)
		sliceListF = append(sliceListF, sliceF.comp)
		sliceListG = append(sliceListG, sliceG.comp)
	}

	for idx := range id {
		lambda(id[idx],
			sliceListA[idx], sliceListB[idx], sliceListC[idx], sliceListD[idx], sliceListE[idx], sliceListF[idx], sliceListG[idx],
		)
	}
}

// --------------------------------------------------------------------------------
// - View 8
// --------------------------------------------------------------------------------

// Represents a view of data in a specific world. Provides access to the components specified in the generic block
type View8[A, B, C, D, E, F, G, H any] struct {
	world  *World
	filter filterList

	storageA *componentStorage[A]
	storageB *componentStorage[B]
	storageC *componentStorage[C]
	storageD *componentStorage[D]
	storageE *componentStorage[E]
	storageF *componentStorage[F]
	storageG *componentStorage[G]
	storageH *componentStorage[H]
}

// implement the intializer interface so that it can be automatically created and injected into systems
func (v *View8[A, B, C, D, E, F, G, H]) initialize(world *World) any {
	// TODO: filters need to be a part of the query type
	return Query8[A, B, C, D, E, F, G, H](world)
}

// Creates a View for the specified world with the specified component filters.
func Query8[A, B, C, D, E, F, G, H any](world *World, filters ...Filter) *View8[A, B, C, D, E, F, G, H] {

	storageA := getStorage[A](world.engine)
	storageB := getStorage[B](world.engine)
	storageC := getStorage[C](world.engine)
	storageD := getStorage[D](world.engine)
	storageE := getStorage[E](world.engine)
	storageF := getStorage[F](world.engine)
	storageG := getStorage[G](world.engine)
	storageH := getStorage[H](world.engine)

	var AA A
	var BB B
	var CC C
	var DD D
	var EE E
	var FF F
	var GG G
	var HH H

	comps := []CompId{

		name(AA),
		name(BB),
		name(CC),
		name(DD),
		name(EE),
		name(FF),
		name(GG),
		name(HH),
	}
	filterList := newFilterList(comps, filters...)
	filterList.regenerate(world)

	v := &View8[A, B, C, D, E, F, G, H]{
		world:  world,
		filter: filterList,

		storageA: storageA,
		storageB: storageB,
		storageC: storageC,
		storageD: storageD,
		storageE: storageE,
		storageF: storageF,
		storageG: storageG,
		storageH: storageH,
	}
	return v
}

// Reads a pointer to the underlying component at the specified id.
// Read will return even if the specified id doesn't match the filter list
// Read will return the value if it exists, else returns nil.
// If you execute any ecs.Write(...) or ecs.Delete(...) this pointer may become invalid.
func (v *View8[A, B, C, D, E, F, G, H]) Read(id Id) (*A, *B, *C, *D, *E, *F, *G, *H) {
	if id == InvalidEntity {
		return nil, nil, nil, nil, nil, nil, nil, nil
	}

	loc, ok := v.world.arch.Get(id)
	if !ok {
		return nil, nil, nil, nil, nil, nil, nil, nil
	}
	lookup := v.world.engine.lookup[loc.archId]
	if lookup == nil {
		panic("LookupList is missing!")
	}
	// index, ok := lookup.index.Get(id)
	// if !ok {
	// 	return nil, nil, nil, nil, nil, nil, nil, nil
	// }
	index := int(loc.index)

	var retA *A
	var retB *B
	var retC *C
	var retD *D
	var retE *E
	var retF *F
	var retG *G
	var retH *H

	sliceA, ok := v.storageA.slice.Get(loc.archId)
	if ok {
		retA = &sliceA.comp[index]
	}
	sliceB, ok := v.storageB.slice.Get(loc.archId)
	if ok {
		retB = &sliceB.comp[index]
	}
	sliceC, ok := v.storageC.slice.Get(loc.archId)
	if ok {
		retC = &sliceC.comp[index]
	}
	sliceD, ok := v.storageD.slice.Get(loc.archId)
	if ok {
		retD = &sliceD.comp[index]
	}
	sliceE, ok := v.storageE.slice.Get(loc.archId)
	if ok {
		retE = &sliceE.comp[index]
	}
	sliceF, ok := v.storageF.slice.Get(loc.archId)
	if ok {
		retF = &sliceF.comp[index]
	}
	sliceG, ok := v.storageG.slice.Get(loc.archId)
	if ok {
		retG = &sliceG.comp[index]
	}
	sliceH, ok := v.storageH.slice.Get(loc.archId)
	if ok {
		retH = &sliceH.comp[index]
	}

	return retA, retB, retC, retD, retE, retF, retG, retH
}

// Counts the number of entities that match this query
func (v *View8[A, B, C, D, E, F, G, H]) Count() int {
	v.filter.regenerate(v.world)

	total := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		total += lookup.Len()
	}
	return total
}

// Maps the lambda function across every entity which matched the specified filters.
func (v *View8[A, B, C, D, E, F, G, H]) MapId(lambda func(id Id, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]
	var compA []A
	var retA *A

	var sliceB *componentList[B]
	var compB []B
	var retB *B

	var sliceC *componentList[C]
	var compC []C
	var retC *C

	var sliceD *componentList[D]
	var compD []D
	var retD *D

	var sliceE *componentList[E]
	var compE []E
	var retE *E

	var sliceF *componentList[F]
	var compF []F
	var retF *F

	var sliceG *componentList[G]
	var compG []G
	var retG *G

	var sliceH *componentList[H]
	var compH []H
	var retH *H

	for _, archId := range v.filter.archIds {

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)
		sliceF, _ = v.storageF.slice.Get(archId)
		sliceG, _ = v.storageG.slice.Get(archId)
		sliceH, _ = v.storageH.slice.Get(archId)

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }
		ids := lookup.id

		// TODO - this flattened version causes a mild performance hit. But the other one combinatorially explodes. I also cant get BCE to work with it. See option 2 for higher performance.

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}
		compF = nil
		if sliceF != nil {
			compF = sliceF.comp
		}
		compG = nil
		if sliceG != nil {
			compG = sliceG.comp
		}
		compH = nil
		if sliceH != nil {
			compH = sliceH.comp
		}

		retA = nil
		retB = nil
		retC = nil
		retD = nil
		retE = nil
		retF = nil
		retG = nil
		retH = nil
		for idx := range ids {
			if ids[idx] == InvalidEntity {
				continue
			} // Skip if its a hole

			if compA != nil {
				retA = &compA[idx]
			}
			if compB != nil {
				retB = &compB[idx]
			}
			if compC != nil {
				retC = &compC[idx]
			}
			if compD != nil {
				retD = &compD[idx]
			}
			if compE != nil {
				retE = &compE[idx]
			}
			if compF != nil {
				retF = &compF[idx]
			}
			if compG != nil {
				retG = &compG[idx]
			}
			if compH != nil {
				retH = &compH[idx]
			}
			lambda(ids[idx], retA, retB, retC, retD, retE, retF, retG, retH)
		}
	}
}

// Maps the lambda function across every entity which matched the specified filters. Components are split based on the number of OS threads available.
func (v *View8[A, B, C, D, E, F, G, H]) MapIdParallel(lambda func(id Id, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]

	var sliceB *componentList[B]

	var sliceC *componentList[C]

	var sliceD *componentList[D]

	var sliceE *componentList[E]

	var sliceF *componentList[F]

	var sliceG *componentList[G]

	var sliceH *componentList[H]

	// 1. Calculate work
	// 2. Calculate number of threads to execute with
	// 3. Greedy divide work among N threads
	// 4. Execute for each in its own goroutine

	// 1. Calculate work
	totalWork := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		// Each id represents an entity that holds the requested component(s)
		// Each hole represents a deleted entity that used to hold the requested component(s)
		totalWork += len(lookup.id) // - len(lookup.holes)
	}

	// 2. Calculate number of threads to execute with
	numThreads := runtime.NumCPU()
	var waitGroup sync.WaitGroup

	type workItem struct {
		ids []Id

		compA []A

		compB []B

		compC []C

		compD []D

		compE []E

		compF []F

		compG []G

		compH []H
	}
	workChannel := make(chan workItem)

	for i := 0; i < numThreads; i++ {
		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			for {
				work, ok := <-workChannel
				if !ok {
					return
				}

				var retA *A
				var retB *B
				var retC *C
				var retD *D
				var retE *E
				var retF *F
				var retG *G
				var retH *H
				for idx := range work.ids {
					if work.ids[idx] == InvalidEntity {
						continue
					} // Skip if its a hole

					if work.compA != nil {
						retA = &work.compA[idx]
					}
					if work.compB != nil {
						retB = &work.compB[idx]
					}
					if work.compC != nil {
						retC = &work.compC[idx]
					}
					if work.compD != nil {
						retD = &work.compD[idx]
					}
					if work.compE != nil {
						retE = &work.compE[idx]
					}
					if work.compF != nil {
						retF = &work.compF[idx]
					}
					if work.compG != nil {
						retG = &work.compG[idx]
					}
					if work.compH != nil {
						retH = &work.compH[idx]
					}
					lambda(work.ids[idx], retA, retB, retC, retD, retE, retF, retG, retH)
				}
			}
		}()
	}

	// 3. Greedy divide work among N threads
	// Simple algorithm:
	// a. Find an evenly balanced distribution per thread
	// b. Generate all work until it gets consumed
	workPerThread := totalWork / numThreads

	// Generate

	var compA []A

	var compB []B

	var compC []C

	var compD []D

	var compE []E

	var compF []F

	var compG []G

	var compH []H

	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		ids := lookup.id

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)
		sliceF, _ = v.storageF.slice.Get(archId)
		sliceG, _ = v.storageG.slice.Get(archId)
		sliceH, _ = v.storageH.slice.Get(archId)

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}
		compF = nil
		if sliceF != nil {
			compF = sliceF.comp
		}
		compG = nil
		if sliceG != nil {
			compG = sliceG.comp
		}
		compH = nil
		if sliceH != nil {
			compH = sliceH.comp
		}

		// workPerformed := 0

		start := 0
		end := 0
		numWorkItems := (len(ids) / workPerThread) + 1
		actualWorkPerThread := (len(ids) / numWorkItems) + 1
		for i := 0; i < numWorkItems; i++ {
			start = i * actualWorkPerThread
			end = (i + 1) * actualWorkPerThread
			if end > len(ids) {
				end = len(ids)
			}

			// workPerformed += len(ids[start:end])
			workChannel <- workItem{
				ids: ids[start:end],

				compA: compA[start:end],

				compB: compB[start:end],

				compC: compC[start:end],

				compD: compD[start:end],

				compE: compE[start:end],

				compF: compF[start:end],

				compG: compG[start:end],

				compH: compH[start:end],
			}
		}

		// if workPerformed != len(ids) {
		// 	panic("wrong")
		// }
	}

	close(workChannel)
	waitGroup.Wait()
}

// Deprecated: This API is a tentative alternative way to map
func (v *View8[A, B, C, D, E, F, G, H]) MapSlices(lambda func(id []Id, a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H)) {
	v.filter.regenerate(v.world)

	id := make([][]Id, 0)

	sliceListA := make([][]A, 0)
	sliceListB := make([][]B, 0)
	sliceListC := make([][]C, 0)
	sliceListD := make([][]D, 0)
	sliceListE := make([][]E, 0)
	sliceListF := make([][]F, 0)
	sliceListG := make([][]G, 0)
	sliceListH := make([][]H, 0)

	for _, archId := range v.filter.archIds {

		sliceA, ok := v.storageA.slice.Get(archId)
		if !ok {
			continue
		}
		sliceB, ok := v.storageB.slice.Get(archId)
		if !ok {
			continue
		}
		sliceC, ok := v.storageC.slice.Get(archId)
		if !ok {
			continue
		}
		sliceD, ok := v.storageD.slice.Get(archId)
		if !ok {
			continue
		}
		sliceE, ok := v.storageE.slice.Get(archId)
		if !ok {
			continue
		}
		sliceF, ok := v.storageF.slice.Get(archId)
		if !ok {
			continue
		}
		sliceG, ok := v.storageG.slice.Get(archId)
		if !ok {
			continue
		}
		sliceH, ok := v.storageH.slice.Get(archId)
		if !ok {
			continue
		}

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }

		id = append(id, lookup.id)

		sliceListA = append(sliceListA, sliceA.comp)
		sliceListB = append(sliceListB, sliceB.comp)
		sliceListC = append(sliceListC, sliceC.comp)
		sliceListD = append(sliceListD, sliceD.comp)
		sliceListE = append(sliceListE, sliceE.comp)
		sliceListF = append(sliceListF, sliceF.comp)
		sliceListG = append(sliceListG, sliceG.comp)
		sliceListH = append(sliceListH, sliceH.comp)
	}

	for idx := range id {
		lambda(id[idx],
			sliceListA[idx], sliceListB[idx], sliceListC[idx], sliceListD[idx], sliceListE[idx], sliceListF[idx], sliceListG[idx], sliceListH[idx],
		)
	}
}

// --------------------------------------------------------------------------------
// - View 9
// --------------------------------------------------------------------------------

// Represents a view of data in a specific world. Provides access to the components specified in the generic block
type View9[A, B, C, D, E, F, G, H, I any] struct {
	world  *World
	filter filterList

	storageA *componentStorage[A]
	storageB *componentStorage[B]
	storageC *componentStorage[C]
	storageD *componentStorage[D]
	storageE *componentStorage[E]
	storageF *componentStorage[F]
	storageG *componentStorage[G]
	storageH *componentStorage[H]
	storageI *componentStorage[I]
}

// implement the intializer interface so that it can be automatically created and injected into systems
func (v *View9[A, B, C, D, E, F, G, H, I]) initialize(world *World) any {
	// TODO: filters need to be a part of the query type
	return Query9[A, B, C, D, E, F, G, H, I](world)
}

// Creates a View for the specified world with the specified component filters.
func Query9[A, B, C, D, E, F, G, H, I any](world *World, filters ...Filter) *View9[A, B, C, D, E, F, G, H, I] {

	storageA := getStorage[A](world.engine)
	storageB := getStorage[B](world.engine)
	storageC := getStorage[C](world.engine)
	storageD := getStorage[D](world.engine)
	storageE := getStorage[E](world.engine)
	storageF := getStorage[F](world.engine)
	storageG := getStorage[G](world.engine)
	storageH := getStorage[H](world.engine)
	storageI := getStorage[I](world.engine)

	var AA A
	var BB B
	var CC C
	var DD D
	var EE E
	var FF F
	var GG G
	var HH H
	var II I

	comps := []CompId{

		name(AA),
		name(BB),
		name(CC),
		name(DD),
		name(EE),
		name(FF),
		name(GG),
		name(HH),
		name(II),
	}
	filterList := newFilterList(comps, filters...)
	filterList.regenerate(world)

	v := &View9[A, B, C, D, E, F, G, H, I]{
		world:  world,
		filter: filterList,

		storageA: storageA,
		storageB: storageB,
		storageC: storageC,
		storageD: storageD,
		storageE: storageE,
		storageF: storageF,
		storageG: storageG,
		storageH: storageH,
		storageI: storageI,
	}
	return v
}

// Reads a pointer to the underlying component at the specified id.
// Read will return even if the specified id doesn't match the filter list
// Read will return the value if it exists, else returns nil.
// If you execute any ecs.Write(...) or ecs.Delete(...) this pointer may become invalid.
func (v *View9[A, B, C, D, E, F, G, H, I]) Read(id Id) (*A, *B, *C, *D, *E, *F, *G, *H, *I) {
	if id == InvalidEntity {
		return nil, nil, nil, nil, nil, nil, nil, nil, nil
	}

	loc, ok := v.world.arch.Get(id)
	if !ok {
		return nil, nil, nil, nil, nil, nil, nil, nil, nil
	}
	lookup := v.world.engine.lookup[loc.archId]
	if lookup == nil {
		panic("LookupList is missing!")
	}
	// index, ok := lookup.index.Get(id)
	// if !ok {
	// 	return nil, nil, nil, nil, nil, nil, nil, nil, nil
	// }
	index := int(loc.index)

	var retA *A
	var retB *B
	var retC *C
	var retD *D
	var retE *E
	var retF *F
	var retG *G
	var retH *H
	var retI *I

	sliceA, ok := v.storageA.slice.Get(loc.archId)
	if ok {
		retA = &sliceA.comp[index]
	}
	sliceB, ok := v.storageB.slice.Get(loc.archId)
	if ok {
		retB = &sliceB.comp[index]
	}
	sliceC, ok := v.storageC.slice.Get(loc.archId)
	if ok {
		retC = &sliceC.comp[index]
	}
	sliceD, ok := v.storageD.slice.Get(loc.archId)
	if ok {
		retD = &sliceD.comp[index]
	}
	sliceE, ok := v.storageE.slice.Get(loc.archId)
	if ok {
		retE = &sliceE.comp[index]
	}
	sliceF, ok := v.storageF.slice.Get(loc.archId)
	if ok {
		retF = &sliceF.comp[index]
	}
	sliceG, ok := v.storageG.slice.Get(loc.archId)
	if ok {
		retG = &sliceG.comp[index]
	}
	sliceH, ok := v.storageH.slice.Get(loc.archId)
	if ok {
		retH = &sliceH.comp[index]
	}
	sliceI, ok := v.storageI.slice.Get(loc.archId)
	if ok {
		retI = &sliceI.comp[index]
	}

	return retA, retB, retC, retD, retE, retF, retG, retH, retI
}

// Counts the number of entities that match this query
func (v *View9[A, B, C, D, E, F, G, H, I]) Count() int {
	v.filter.regenerate(v.world)

	total := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		total += lookup.Len()
	}
	return total
}

// Maps the lambda function across every entity which matched the specified filters.
func (v *View9[A, B, C, D, E, F, G, H, I]) MapId(lambda func(id Id, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]
	var compA []A
	var retA *A

	var sliceB *componentList[B]
	var compB []B
	var retB *B

	var sliceC *componentList[C]
	var compC []C
	var retC *C

	var sliceD *componentList[D]
	var compD []D
	var retD *D

	var sliceE *componentList[E]
	var compE []E
	var retE *E

	var sliceF *componentList[F]
	var compF []F
	var retF *F

	var sliceG *componentList[G]
	var compG []G
	var retG *G

	var sliceH *componentList[H]
	var compH []H
	var retH *H

	var sliceI *componentList[I]
	var compI []I
	var retI *I

	for _, archId := range v.filter.archIds {

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)
		sliceF, _ = v.storageF.slice.Get(archId)
		sliceG, _ = v.storageG.slice.Get(archId)
		sliceH, _ = v.storageH.slice.Get(archId)
		sliceI, _ = v.storageI.slice.Get(archId)

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }
		ids := lookup.id

		// TODO - this flattened version causes a mild performance hit. But the other one combinatorially explodes. I also cant get BCE to work with it. See option 2 for higher performance.

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}
		compF = nil
		if sliceF != nil {
			compF = sliceF.comp
		}
		compG = nil
		if sliceG != nil {
			compG = sliceG.comp
		}
		compH = nil
		if sliceH != nil {
			compH = sliceH.comp
		}
		compI = nil
		if sliceI != nil {
			compI = sliceI.comp
		}

		retA = nil
		retB = nil
		retC = nil
		retD = nil
		retE = nil
		retF = nil
		retG = nil
		retH = nil
		retI = nil
		for idx := range ids {
			if ids[idx] == InvalidEntity {
				continue
			} // Skip if its a hole

			if compA != nil {
				retA = &compA[idx]
			}
			if compB != nil {
				retB = &compB[idx]
			}
			if compC != nil {
				retC = &compC[idx]
			}
			if compD != nil {
				retD = &compD[idx]
			}
			if compE != nil {
				retE = &compE[idx]
			}
			if compF != nil {
				retF = &compF[idx]
			}
			if compG != nil {
				retG = &compG[idx]
			}
			if compH != nil {
				retH = &compH[idx]
			}
			if compI != nil {
				retI = &compI[idx]
			}
			lambda(ids[idx], retA, retB, retC, retD, retE, retF, retG, retH, retI)
		}
	}
}

// Maps the lambda function across every entity which matched the specified filters. Components are split based on the number of OS threads available.
func (v *View9[A, B, C, D, E, F, G, H, I]) MapIdParallel(lambda func(id Id, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]

	var sliceB *componentList[B]

	var sliceC *componentList[C]

	var sliceD *componentList[D]

	var sliceE *componentList[E]

	var sliceF *componentList[F]

	var sliceG *componentList[G]

	var sliceH *componentList[H]

	var sliceI *componentList[I]

	// 1. Calculate work
	// 2. Calculate number of threads to execute with
	// 3. Greedy divide work among N threads
	// 4. Execute for each in its own goroutine

	// 1. Calculate work
	totalWork := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		// Each id represents an entity that holds the requested component(s)
		// Each hole represents a deleted entity that used to hold the requested component(s)
		totalWork += len(lookup.id) // - len(lookup.holes)
	}

	// 2. Calculate number of threads to execute with
	numThreads := runtime.NumCPU()
	var waitGroup sync.WaitGroup

	type workItem struct {
		ids []Id

		compA []A

		compB []B

		compC []C

		compD []D

		compE []E

		compF []F

		compG []G

		compH []H

		compI []I
	}
	workChannel := make(chan workItem)

	for i := 0; i < numThreads; i++ {
		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			for {
				work, ok := <-workChannel
				if !ok {
					return
				}

				var retA *A
				var retB *B
				var retC *C
				var retD *D
				var retE *E
				var retF *F
				var retG *G
				var retH *H
				var retI *I
				for idx := range work.ids {
					if work.ids[idx] == InvalidEntity {
						continue
					} // Skip if its a hole

					if work.compA != nil {
						retA = &work.compA[idx]
					}
					if work.compB != nil {
						retB = &work.compB[idx]
					}
					if work.compC != nil {
						retC = &work.compC[idx]
					}
					if work.compD != nil {
						retD = &work.compD[idx]
					}
					if work.compE != nil {
						retE = &work.compE[idx]
					}
					if work.compF != nil {
						retF = &work.compF[idx]
					}
					if work.compG != nil {
						retG = &work.compG[idx]
					}
					if work.compH != nil {
						retH = &work.compH[idx]
					}
					if work.compI != nil {
						retI = &work.compI[idx]
					}
					lambda(work.ids[idx], retA, retB, retC, retD, retE, retF, retG, retH, retI)
				}
			}
		}()
	}

	// 3. Greedy divide work among N threads
	// Simple algorithm:
	// a. Find an evenly balanced distribution per thread
	// b. Generate all work until it gets consumed
	workPerThread := totalWork / numThreads

	// Generate

	var compA []A

	var compB []B

	var compC []C

	var compD []D

	var compE []E

	var compF []F

	var compG []G

	var compH []H

	var compI []I

	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		ids := lookup.id

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)
		sliceF, _ = v.storageF.slice.Get(archId)
		sliceG, _ = v.storageG.slice.Get(archId)
		sliceH, _ = v.storageH.slice.Get(archId)
		sliceI, _ = v.storageI.slice.Get(archId)

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}
		compF = nil
		if sliceF != nil {
			compF = sliceF.comp
		}
		compG = nil
		if sliceG != nil {
			compG = sliceG.comp
		}
		compH = nil
		if sliceH != nil {
			compH = sliceH.comp
		}
		compI = nil
		if sliceI != nil {
			compI = sliceI.comp
		}

		// workPerformed := 0

		start := 0
		end := 0
		numWorkItems := (len(ids) / workPerThread) + 1
		actualWorkPerThread := (len(ids) / numWorkItems) + 1
		for i := 0; i < numWorkItems; i++ {
			start = i * actualWorkPerThread
			end = (i + 1) * actualWorkPerThread
			if end > len(ids) {
				end = len(ids)
			}

			// workPerformed += len(ids[start:end])
			workChannel <- workItem{
				ids: ids[start:end],

				compA: compA[start:end],

				compB: compB[start:end],

				compC: compC[start:end],

				compD: compD[start:end],

				compE: compE[start:end],

				compF: compF[start:end],

				compG: compG[start:end],

				compH: compH[start:end],

				compI: compI[start:end],
			}
		}

		// if workPerformed != len(ids) {
		// 	panic("wrong")
		// }
	}

	close(workChannel)
	waitGroup.Wait()
}

// Deprecated: This API is a tentative alternative way to map
func (v *View9[A, B, C, D, E, F, G, H, I]) MapSlices(lambda func(id []Id, a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I)) {
	v.filter.regenerate(v.world)

	id := make([][]Id, 0)

	sliceListA := make([][]A, 0)
	sliceListB := make([][]B, 0)
	sliceListC := make([][]C, 0)
	sliceListD := make([][]D, 0)
	sliceListE := make([][]E, 0)
	sliceListF := make([][]F, 0)
	sliceListG := make([][]G, 0)
	sliceListH := make([][]H, 0)
	sliceListI := make([][]I, 0)

	for _, archId := range v.filter.archIds {

		sliceA, ok := v.storageA.slice.Get(archId)
		if !ok {
			continue
		}
		sliceB, ok := v.storageB.slice.Get(archId)
		if !ok {
			continue
		}
		sliceC, ok := v.storageC.slice.Get(archId)
		if !ok {
			continue
		}
		sliceD, ok := v.storageD.slice.Get(archId)
		if !ok {
			continue
		}
		sliceE, ok := v.storageE.slice.Get(archId)
		if !ok {
			continue
		}
		sliceF, ok := v.storageF.slice.Get(archId)
		if !ok {
			continue
		}
		sliceG, ok := v.storageG.slice.Get(archId)
		if !ok {
			continue
		}
		sliceH, ok := v.storageH.slice.Get(archId)
		if !ok {
			continue
		}
		sliceI, ok := v.storageI.slice.Get(archId)
		if !ok {
			continue
		}

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }

		id = append(id, lookup.id)

		sliceListA = append(sliceListA, sliceA.comp)
		sliceListB = append(sliceListB, sliceB.comp)
		sliceListC = append(sliceListC, sliceC.comp)
		sliceListD = append(sliceListD, sliceD.comp)
		sliceListE = append(sliceListE, sliceE.comp)
		sliceListF = append(sliceListF, sliceF.comp)
		sliceListG = append(sliceListG, sliceG.comp)
		sliceListH = append(sliceListH, sliceH.comp)
		sliceListI = append(sliceListI, sliceI.comp)
	}

	for idx := range id {
		lambda(id[idx],
			sliceListA[idx], sliceListB[idx], sliceListC[idx], sliceListD[idx], sliceListE[idx], sliceListF[idx], sliceListG[idx], sliceListH[idx], sliceListI[idx],
		)
	}
}

// --------------------------------------------------------------------------------
// - View 10
// --------------------------------------------------------------------------------

// Represents a view of data in a specific world. Provides access to the components specified in the generic block
type View10[A, B, C, D, E, F, G, H, I, J any] struct {
	world  *World
	filter filterList

	storageA *componentStorage[A]
	storageB *componentStorage[B]
	storageC *componentStorage[C]
	storageD *componentStorage[D]
	storageE *componentStorage[E]
	storageF *componentStorage[F]
	storageG *componentStorage[G]
	storageH *componentStorage[H]
	storageI *componentStorage[I]
	storageJ *componentStorage[J]
}

// implement the intializer interface so that it can be automatically created and injected into systems
func (v *View10[A, B, C, D, E, F, G, H, I, J]) initialize(world *World) any {
	// TODO: filters need to be a part of the query type
	return Query10[A, B, C, D, E, F, G, H, I, J](world)
}

// Creates a View for the specified world with the specified component filters.
func Query10[A, B, C, D, E, F, G, H, I, J any](world *World, filters ...Filter) *View10[A, B, C, D, E, F, G, H, I, J] {

	storageA := getStorage[A](world.engine)
	storageB := getStorage[B](world.engine)
	storageC := getStorage[C](world.engine)
	storageD := getStorage[D](world.engine)
	storageE := getStorage[E](world.engine)
	storageF := getStorage[F](world.engine)
	storageG := getStorage[G](world.engine)
	storageH := getStorage[H](world.engine)
	storageI := getStorage[I](world.engine)
	storageJ := getStorage[J](world.engine)

	var AA A
	var BB B
	var CC C
	var DD D
	var EE E
	var FF F
	var GG G
	var HH H
	var II I
	var JJ J

	comps := []CompId{

		name(AA),
		name(BB),
		name(CC),
		name(DD),
		name(EE),
		name(FF),
		name(GG),
		name(HH),
		name(II),
		name(JJ),
	}
	filterList := newFilterList(comps, filters...)
	filterList.regenerate(world)

	v := &View10[A, B, C, D, E, F, G, H, I, J]{
		world:  world,
		filter: filterList,

		storageA: storageA,
		storageB: storageB,
		storageC: storageC,
		storageD: storageD,
		storageE: storageE,
		storageF: storageF,
		storageG: storageG,
		storageH: storageH,
		storageI: storageI,
		storageJ: storageJ,
	}
	return v
}

// Reads a pointer to the underlying component at the specified id.
// Read will return even if the specified id doesn't match the filter list
// Read will return the value if it exists, else returns nil.
// If you execute any ecs.Write(...) or ecs.Delete(...) this pointer may become invalid.
func (v *View10[A, B, C, D, E, F, G, H, I, J]) Read(id Id) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J) {
	if id == InvalidEntity {
		return nil, nil, nil, nil, nil, nil, nil, nil, nil, nil
	}

	loc, ok := v.world.arch.Get(id)
	if !ok {
		return nil, nil, nil, nil, nil, nil, nil, nil, nil, nil
	}
	lookup := v.world.engine.lookup[loc.archId]
	if lookup == nil {
		panic("LookupList is missing!")
	}
	// index, ok := lookup.index.Get(id)
	// if !ok {
	// 	return nil, nil, nil, nil, nil, nil, nil, nil, nil, nil
	// }
	index := int(loc.index)

	var retA *A
	var retB *B
	var retC *C
	var retD *D
	var retE *E
	var retF *F
	var retG *G
	var retH *H
	var retI *I
	var retJ *J

	sliceA, ok := v.storageA.slice.Get(loc.archId)
	if ok {
		retA = &sliceA.comp[index]
	}
	sliceB, ok := v.storageB.slice.Get(loc.archId)
	if ok {
		retB = &sliceB.comp[index]
	}
	sliceC, ok := v.storageC.slice.Get(loc.archId)
	if ok {
		retC = &sliceC.comp[index]
	}
	sliceD, ok := v.storageD.slice.Get(loc.archId)
	if ok {
		retD = &sliceD.comp[index]
	}
	sliceE, ok := v.storageE.slice.Get(loc.archId)
	if ok {
		retE = &sliceE.comp[index]
	}
	sliceF, ok := v.storageF.slice.Get(loc.archId)
	if ok {
		retF = &sliceF.comp[index]
	}
	sliceG, ok := v.storageG.slice.Get(loc.archId)
	if ok {
		retG = &sliceG.comp[index]
	}
	sliceH, ok := v.storageH.slice.Get(loc.archId)
	if ok {
		retH = &sliceH.comp[index]
	}
	sliceI, ok := v.storageI.slice.Get(loc.archId)
	if ok {
		retI = &sliceI.comp[index]
	}
	sliceJ, ok := v.storageJ.slice.Get(loc.archId)
	if ok {
		retJ = &sliceJ.comp[index]
	}

	return retA, retB, retC, retD, retE, retF, retG, retH, retI, retJ
}

// Counts the number of entities that match this query
func (v *View10[A, B, C, D, E, F, G, H, I, J]) Count() int {
	v.filter.regenerate(v.world)

	total := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		total += lookup.Len()
	}
	return total
}

// Maps the lambda function across every entity which matched the specified filters.
func (v *View10[A, B, C, D, E, F, G, H, I, J]) MapId(lambda func(id Id, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]
	var compA []A
	var retA *A

	var sliceB *componentList[B]
	var compB []B
	var retB *B

	var sliceC *componentList[C]
	var compC []C
	var retC *C

	var sliceD *componentList[D]
	var compD []D
	var retD *D

	var sliceE *componentList[E]
	var compE []E
	var retE *E

	var sliceF *componentList[F]
	var compF []F
	var retF *F

	var sliceG *componentList[G]
	var compG []G
	var retG *G

	var sliceH *componentList[H]
	var compH []H
	var retH *H

	var sliceI *componentList[I]
	var compI []I
	var retI *I

	var sliceJ *componentList[J]
	var compJ []J
	var retJ *J

	for _, archId := range v.filter.archIds {

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)
		sliceF, _ = v.storageF.slice.Get(archId)
		sliceG, _ = v.storageG.slice.Get(archId)
		sliceH, _ = v.storageH.slice.Get(archId)
		sliceI, _ = v.storageI.slice.Get(archId)
		sliceJ, _ = v.storageJ.slice.Get(archId)

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }
		ids := lookup.id

		// TODO - this flattened version causes a mild performance hit. But the other one combinatorially explodes. I also cant get BCE to work with it. See option 2 for higher performance.

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}
		compF = nil
		if sliceF != nil {
			compF = sliceF.comp
		}
		compG = nil
		if sliceG != nil {
			compG = sliceG.comp
		}
		compH = nil
		if sliceH != nil {
			compH = sliceH.comp
		}
		compI = nil
		if sliceI != nil {
			compI = sliceI.comp
		}
		compJ = nil
		if sliceJ != nil {
			compJ = sliceJ.comp
		}

		retA = nil
		retB = nil
		retC = nil
		retD = nil
		retE = nil
		retF = nil
		retG = nil
		retH = nil
		retI = nil
		retJ = nil
		for idx := range ids {
			if ids[idx] == InvalidEntity {
				continue
			} // Skip if its a hole

			if compA != nil {
				retA = &compA[idx]
			}
			if compB != nil {
				retB = &compB[idx]
			}
			if compC != nil {
				retC = &compC[idx]
			}
			if compD != nil {
				retD = &compD[idx]
			}
			if compE != nil {
				retE = &compE[idx]
			}
			if compF != nil {
				retF = &compF[idx]
			}
			if compG != nil {
				retG = &compG[idx]
			}
			if compH != nil {
				retH = &compH[idx]
			}
			if compI != nil {
				retI = &compI[idx]
			}
			if compJ != nil {
				retJ = &compJ[idx]
			}
			lambda(ids[idx], retA, retB, retC, retD, retE, retF, retG, retH, retI, retJ)
		}
	}
}

// Maps the lambda function across every entity which matched the specified filters. Components are split based on the number of OS threads available.
func (v *View10[A, B, C, D, E, F, G, H, I, J]) MapIdParallel(lambda func(id Id, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]

	var sliceB *componentList[B]

	var sliceC *componentList[C]

	var sliceD *componentList[D]

	var sliceE *componentList[E]

	var sliceF *componentList[F]

	var sliceG *componentList[G]

	var sliceH *componentList[H]

	var sliceI *componentList[I]

	var sliceJ *componentList[J]

	// 1. Calculate work
	// 2. Calculate number of threads to execute with
	// 3. Greedy divide work among N threads
	// 4. Execute for each in its own goroutine

	// 1. Calculate work
	totalWork := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		// Each id represents an entity that holds the requested component(s)
		// Each hole represents a deleted entity that used to hold the requested component(s)
		totalWork += len(lookup.id) // - len(lookup.holes)
	}

	// 2. Calculate number of threads to execute with
	numThreads := runtime.NumCPU()
	var waitGroup sync.WaitGroup

	type workItem struct {
		ids []Id

		compA []A

		compB []B

		compC []C

		compD []D

		compE []E

		compF []F

		compG []G

		compH []H

		compI []I

		compJ []J
	}
	workChannel := make(chan workItem)

	for i := 0; i < numThreads; i++ {
		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			for {
				work, ok := <-workChannel
				if !ok {
					return
				}

				var retA *A
				var retB *B
				var retC *C
				var retD *D
				var retE *E
				var retF *F
				var retG *G
				var retH *H
				var retI *I
				var retJ *J
				for idx := range work.ids {
					if work.ids[idx] == InvalidEntity {
						continue
					} // Skip if its a hole

					if work.compA != nil {
						retA = &work.compA[idx]
					}
					if work.compB != nil {
						retB = &work.compB[idx]
					}
					if work.compC != nil {
						retC = &work.compC[idx]
					}
					if work.compD != nil {
						retD = &work.compD[idx]
					}
					if work.compE != nil {
						retE = &work.compE[idx]
					}
					if work.compF != nil {
						retF = &work.compF[idx]
					}
					if work.compG != nil {
						retG = &work.compG[idx]
					}
					if work.compH != nil {
						retH = &work.compH[idx]
					}
					if work.compI != nil {
						retI = &work.compI[idx]
					}
					if work.compJ != nil {
						retJ = &work.compJ[idx]
					}
					lambda(work.ids[idx], retA, retB, retC, retD, retE, retF, retG, retH, retI, retJ)
				}
			}
		}()
	}

	// 3. Greedy divide work among N threads
	// Simple algorithm:
	// a. Find an evenly balanced distribution per thread
	// b. Generate all work until it gets consumed
	workPerThread := totalWork / numThreads

	// Generate

	var compA []A

	var compB []B

	var compC []C

	var compD []D

	var compE []E

	var compF []F

	var compG []G

	var compH []H

	var compI []I

	var compJ []J

	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		ids := lookup.id

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)
		sliceF, _ = v.storageF.slice.Get(archId)
		sliceG, _ = v.storageG.slice.Get(archId)
		sliceH, _ = v.storageH.slice.Get(archId)
		sliceI, _ = v.storageI.slice.Get(archId)
		sliceJ, _ = v.storageJ.slice.Get(archId)

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}
		compF = nil
		if sliceF != nil {
			compF = sliceF.comp
		}
		compG = nil
		if sliceG != nil {
			compG = sliceG.comp
		}
		compH = nil
		if sliceH != nil {
			compH = sliceH.comp
		}
		compI = nil
		if sliceI != nil {
			compI = sliceI.comp
		}
		compJ = nil
		if sliceJ != nil {
			compJ = sliceJ.comp
		}

		// workPerformed := 0

		start := 0
		end := 0
		numWorkItems := (len(ids) / workPerThread) + 1
		actualWorkPerThread := (len(ids) / numWorkItems) + 1
		for i := 0; i < numWorkItems; i++ {
			start = i * actualWorkPerThread
			end = (i + 1) * actualWorkPerThread
			if end > len(ids) {
				end = len(ids)
			}

			// workPerformed += len(ids[start:end])
			workChannel <- workItem{
				ids: ids[start:end],

				compA: compA[start:end],

				compB: compB[start:end],

				compC: compC[start:end],

				compD: compD[start:end],

				compE: compE[start:end],

				compF: compF[start:end],

				compG: compG[start:end],

				compH: compH[start:end],

				compI: compI[start:end],

				compJ: compJ[start:end],
			}
		}

		// if workPerformed != len(ids) {
		// 	panic("wrong")
		// }
	}

	close(workChannel)
	waitGroup.Wait()
}

// Deprecated: This API is a tentative alternative way to map
func (v *View10[A, B, C, D, E, F, G, H, I, J]) MapSlices(lambda func(id []Id, a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I, j []J)) {
	v.filter.regenerate(v.world)

	id := make([][]Id, 0)

	sliceListA := make([][]A, 0)
	sliceListB := make([][]B, 0)
	sliceListC := make([][]C, 0)
	sliceListD := make([][]D, 0)
	sliceListE := make([][]E, 0)
	sliceListF := make([][]F, 0)
	sliceListG := make([][]G, 0)
	sliceListH := make([][]H, 0)
	sliceListI := make([][]I, 0)
	sliceListJ := make([][]J, 0)

	for _, archId := range v.filter.archIds {

		sliceA, ok := v.storageA.slice.Get(archId)
		if !ok {
			continue
		}
		sliceB, ok := v.storageB.slice.Get(archId)
		if !ok {
			continue
		}
		sliceC, ok := v.storageC.slice.Get(archId)
		if !ok {
			continue
		}
		sliceD, ok := v.storageD.slice.Get(archId)
		if !ok {
			continue
		}
		sliceE, ok := v.storageE.slice.Get(archId)
		if !ok {
			continue
		}
		sliceF, ok := v.storageF.slice.Get(archId)
		if !ok {
			continue
		}
		sliceG, ok := v.storageG.slice.Get(archId)
		if !ok {
			continue
		}
		sliceH, ok := v.storageH.slice.Get(archId)
		if !ok {
			continue
		}
		sliceI, ok := v.storageI.slice.Get(archId)
		if !ok {
			continue
		}
		sliceJ, ok := v.storageJ.slice.Get(archId)
		if !ok {
			continue
		}

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }

		id = append(id, lookup.id)

		sliceListA = append(sliceListA, sliceA.comp)
		sliceListB = append(sliceListB, sliceB.comp)
		sliceListC = append(sliceListC, sliceC.comp)
		sliceListD = append(sliceListD, sliceD.comp)
		sliceListE = append(sliceListE, sliceE.comp)
		sliceListF = append(sliceListF, sliceF.comp)
		sliceListG = append(sliceListG, sliceG.comp)
		sliceListH = append(sliceListH, sliceH.comp)
		sliceListI = append(sliceListI, sliceI.comp)
		sliceListJ = append(sliceListJ, sliceJ.comp)
	}

	for idx := range id {
		lambda(id[idx],
			sliceListA[idx], sliceListB[idx], sliceListC[idx], sliceListD[idx], sliceListE[idx], sliceListF[idx], sliceListG[idx], sliceListH[idx], sliceListI[idx], sliceListJ[idx],
		)
	}
}

// --------------------------------------------------------------------------------
// - View 11
// --------------------------------------------------------------------------------

// Represents a view of data in a specific world. Provides access to the components specified in the generic block
type View11[A, B, C, D, E, F, G, H, I, J, K any] struct {
	world  *World
	filter filterList

	storageA *componentStorage[A]
	storageB *componentStorage[B]
	storageC *componentStorage[C]
	storageD *componentStorage[D]
	storageE *componentStorage[E]
	storageF *componentStorage[F]
	storageG *componentStorage[G]
	storageH *componentStorage[H]
	storageI *componentStorage[I]
	storageJ *componentStorage[J]
	storageK *componentStorage[K]
}

// implement the intializer interface so that it can be automatically created and injected into systems
func (v *View11[A, B, C, D, E, F, G, H, I, J, K]) initialize(world *World) any {
	// TODO: filters need to be a part of the query type
	return Query11[A, B, C, D, E, F, G, H, I, J, K](world)
}

// Creates a View for the specified world with the specified component filters.
func Query11[A, B, C, D, E, F, G, H, I, J, K any](world *World, filters ...Filter) *View11[A, B, C, D, E, F, G, H, I, J, K] {

	storageA := getStorage[A](world.engine)
	storageB := getStorage[B](world.engine)
	storageC := getStorage[C](world.engine)
	storageD := getStorage[D](world.engine)
	storageE := getStorage[E](world.engine)
	storageF := getStorage[F](world.engine)
	storageG := getStorage[G](world.engine)
	storageH := getStorage[H](world.engine)
	storageI := getStorage[I](world.engine)
	storageJ := getStorage[J](world.engine)
	storageK := getStorage[K](world.engine)

	var AA A
	var BB B
	var CC C
	var DD D
	var EE E
	var FF F
	var GG G
	var HH H
	var II I
	var JJ J
	var KK K

	comps := []CompId{

		name(AA),
		name(BB),
		name(CC),
		name(DD),
		name(EE),
		name(FF),
		name(GG),
		name(HH),
		name(II),
		name(JJ),
		name(KK),
	}
	filterList := newFilterList(comps, filters...)
	filterList.regenerate(world)

	v := &View11[A, B, C, D, E, F, G, H, I, J, K]{
		world:  world,
		filter: filterList,

		storageA: storageA,
		storageB: storageB,
		storageC: storageC,
		storageD: storageD,
		storageE: storageE,
		storageF: storageF,
		storageG: storageG,
		storageH: storageH,
		storageI: storageI,
		storageJ: storageJ,
		storageK: storageK,
	}
	return v
}

// Reads a pointer to the underlying component at the specified id.
// Read will return even if the specified id doesn't match the filter list
// Read will return the value if it exists, else returns nil.
// If you execute any ecs.Write(...) or ecs.Delete(...) this pointer may become invalid.
func (v *View11[A, B, C, D, E, F, G, H, I, J, K]) Read(id Id) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K) {
	if id == InvalidEntity {
		return nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil
	}

	loc, ok := v.world.arch.Get(id)
	if !ok {
		return nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil
	}
	lookup := v.world.engine.lookup[loc.archId]
	if lookup == nil {
		panic("LookupList is missing!")
	}
	// index, ok := lookup.index.Get(id)
	// if !ok {
	// 	return nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil
	// }
	index := int(loc.index)

	var retA *A
	var retB *B
	var retC *C
	var retD *D
	var retE *E
	var retF *F
	var retG *G
	var retH *H
	var retI *I
	var retJ *J
	var retK *K

	sliceA, ok := v.storageA.slice.Get(loc.archId)
	if ok {
		retA = &sliceA.comp[index]
	}
	sliceB, ok := v.storageB.slice.Get(loc.archId)
	if ok {
		retB = &sliceB.comp[index]
	}
	sliceC, ok := v.storageC.slice.Get(loc.archId)
	if ok {
		retC = &sliceC.comp[index]
	}
	sliceD, ok := v.storageD.slice.Get(loc.archId)
	if ok {
		retD = &sliceD.comp[index]
	}
	sliceE, ok := v.storageE.slice.Get(loc.archId)
	if ok {
		retE = &sliceE.comp[index]
	}
	sliceF, ok := v.storageF.slice.Get(loc.archId)
	if ok {
		retF = &sliceF.comp[index]
	}
	sliceG, ok := v.storageG.slice.Get(loc.archId)
	if ok {
		retG = &sliceG.comp[index]
	}
	sliceH, ok := v.storageH.slice.Get(loc.archId)
	if ok {
		retH = &sliceH.comp[index]
	}
	sliceI, ok := v.storageI.slice.Get(loc.archId)
	if ok {
		retI = &sliceI.comp[index]
	}
	sliceJ, ok := v.storageJ.slice.Get(loc.archId)
	if ok {
		retJ = &sliceJ.comp[index]
	}
	sliceK, ok := v.storageK.slice.Get(loc.archId)
	if ok {
		retK = &sliceK.comp[index]
	}

	return retA, retB, retC, retD, retE, retF, retG, retH, retI, retJ, retK
}

// Counts the number of entities that match this query
func (v *View11[A, B, C, D, E, F, G, H, I, J, K]) Count() int {
	v.filter.regenerate(v.world)

	total := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		total += lookup.Len()
	}
	return total
}

// Maps the lambda function across every entity which matched the specified filters.
func (v *View11[A, B, C, D, E, F, G, H, I, J, K]) MapId(lambda func(id Id, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]
	var compA []A
	var retA *A

	var sliceB *componentList[B]
	var compB []B
	var retB *B

	var sliceC *componentList[C]
	var compC []C
	var retC *C

	var sliceD *componentList[D]
	var compD []D
	var retD *D

	var sliceE *componentList[E]
	var compE []E
	var retE *E

	var sliceF *componentList[F]
	var compF []F
	var retF *F

	var sliceG *componentList[G]
	var compG []G
	var retG *G

	var sliceH *componentList[H]
	var compH []H
	var retH *H

	var sliceI *componentList[I]
	var compI []I
	var retI *I

	var sliceJ *componentList[J]
	var compJ []J
	var retJ *J

	var sliceK *componentList[K]
	var compK []K
	var retK *K

	for _, archId := range v.filter.archIds {

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)
		sliceF, _ = v.storageF.slice.Get(archId)
		sliceG, _ = v.storageG.slice.Get(archId)
		sliceH, _ = v.storageH.slice.Get(archId)
		sliceI, _ = v.storageI.slice.Get(archId)
		sliceJ, _ = v.storageJ.slice.Get(archId)
		sliceK, _ = v.storageK.slice.Get(archId)

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }
		ids := lookup.id

		// TODO - this flattened version causes a mild performance hit. But the other one combinatorially explodes. I also cant get BCE to work with it. See option 2 for higher performance.

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}
		compF = nil
		if sliceF != nil {
			compF = sliceF.comp
		}
		compG = nil
		if sliceG != nil {
			compG = sliceG.comp
		}
		compH = nil
		if sliceH != nil {
			compH = sliceH.comp
		}
		compI = nil
		if sliceI != nil {
			compI = sliceI.comp
		}
		compJ = nil
		if sliceJ != nil {
			compJ = sliceJ.comp
		}
		compK = nil
		if sliceK != nil {
			compK = sliceK.comp
		}

		retA = nil
		retB = nil
		retC = nil
		retD = nil
		retE = nil
		retF = nil
		retG = nil
		retH = nil
		retI = nil
		retJ = nil
		retK = nil
		for idx := range ids {
			if ids[idx] == InvalidEntity {
				continue
			} // Skip if its a hole

			if compA != nil {
				retA = &compA[idx]
			}
			if compB != nil {
				retB = &compB[idx]
			}
			if compC != nil {
				retC = &compC[idx]
			}
			if compD != nil {
				retD = &compD[idx]
			}
			if compE != nil {
				retE = &compE[idx]
			}
			if compF != nil {
				retF = &compF[idx]
			}
			if compG != nil {
				retG = &compG[idx]
			}
			if compH != nil {
				retH = &compH[idx]
			}
			if compI != nil {
				retI = &compI[idx]
			}
			if compJ != nil {
				retJ = &compJ[idx]
			}
			if compK != nil {
				retK = &compK[idx]
			}
			lambda(ids[idx], retA, retB, retC, retD, retE, retF, retG, retH, retI, retJ, retK)
		}
	}
}

// Maps the lambda function across every entity which matched the specified filters. Components are split based on the number of OS threads available.
func (v *View11[A, B, C, D, E, F, G, H, I, J, K]) MapIdParallel(lambda func(id Id, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]

	var sliceB *componentList[B]

	var sliceC *componentList[C]

	var sliceD *componentList[D]

	var sliceE *componentList[E]

	var sliceF *componentList[F]

	var sliceG *componentList[G]

	var sliceH *componentList[H]

	var sliceI *componentList[I]

	var sliceJ *componentList[J]

	var sliceK *componentList[K]

	// 1. Calculate work
	// 2. Calculate number of threads to execute with
	// 3. Greedy divide work among N threads
	// 4. Execute for each in its own goroutine

	// 1. Calculate work
	totalWork := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		// Each id represents an entity that holds the requested component(s)
		// Each hole represents a deleted entity that used to hold the requested component(s)
		totalWork += len(lookup.id) // - len(lookup.holes)
	}

	// 2. Calculate number of threads to execute with
	numThreads := runtime.NumCPU()
	var waitGroup sync.WaitGroup

	type workItem struct {
		ids []Id

		compA []A

		compB []B

		compC []C

		compD []D

		compE []E

		compF []F

		compG []G

		compH []H

		compI []I

		compJ []J

		compK []K
	}
	workChannel := make(chan workItem)

	for i := 0; i < numThreads; i++ {
		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			for {
				work, ok := <-workChannel
				if !ok {
					return
				}

				var retA *A
				var retB *B
				var retC *C
				var retD *D
				var retE *E
				var retF *F
				var retG *G
				var retH *H
				var retI *I
				var retJ *J
				var retK *K
				for idx := range work.ids {
					if work.ids[idx] == InvalidEntity {
						continue
					} // Skip if its a hole

					if work.compA != nil {
						retA = &work.compA[idx]
					}
					if work.compB != nil {
						retB = &work.compB[idx]
					}
					if work.compC != nil {
						retC = &work.compC[idx]
					}
					if work.compD != nil {
						retD = &work.compD[idx]
					}
					if work.compE != nil {
						retE = &work.compE[idx]
					}
					if work.compF != nil {
						retF = &work.compF[idx]
					}
					if work.compG != nil {
						retG = &work.compG[idx]
					}
					if work.compH != nil {
						retH = &work.compH[idx]
					}
					if work.compI != nil {
						retI = &work.compI[idx]
					}
					if work.compJ != nil {
						retJ = &work.compJ[idx]
					}
					if work.compK != nil {
						retK = &work.compK[idx]
					}
					lambda(work.ids[idx], retA, retB, retC, retD, retE, retF, retG, retH, retI, retJ, retK)
				}
			}
		}()
	}

	// 3. Greedy divide work among N threads
	// Simple algorithm:
	// a. Find an evenly balanced distribution per thread
	// b. Generate all work until it gets consumed
	workPerThread := totalWork / numThreads

	// Generate

	var compA []A

	var compB []B

	var compC []C

	var compD []D

	var compE []E

	var compF []F

	var compG []G

	var compH []H

	var compI []I

	var compJ []J

	var compK []K

	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		ids := lookup.id

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)
		sliceF, _ = v.storageF.slice.Get(archId)
		sliceG, _ = v.storageG.slice.Get(archId)
		sliceH, _ = v.storageH.slice.Get(archId)
		sliceI, _ = v.storageI.slice.Get(archId)
		sliceJ, _ = v.storageJ.slice.Get(archId)
		sliceK, _ = v.storageK.slice.Get(archId)

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}
		compF = nil
		if sliceF != nil {
			compF = sliceF.comp
		}
		compG = nil
		if sliceG != nil {
			compG = sliceG.comp
		}
		compH = nil
		if sliceH != nil {
			compH = sliceH.comp
		}
		compI = nil
		if sliceI != nil {
			compI = sliceI.comp
		}
		compJ = nil
		if sliceJ != nil {
			compJ = sliceJ.comp
		}
		compK = nil
		if sliceK != nil {
			compK = sliceK.comp
		}

		// workPerformed := 0

		start := 0
		end := 0
		numWorkItems := (len(ids) / workPerThread) + 1
		actualWorkPerThread := (len(ids) / numWorkItems) + 1
		for i := 0; i < numWorkItems; i++ {
			start = i * actualWorkPerThread
			end = (i + 1) * actualWorkPerThread
			if end > len(ids) {
				end = len(ids)
			}

			// workPerformed += len(ids[start:end])
			workChannel <- workItem{
				ids: ids[start:end],

				compA: compA[start:end],

				compB: compB[start:end],

				compC: compC[start:end],

				compD: compD[start:end],

				compE: compE[start:end],

				compF: compF[start:end],

				compG: compG[start:end],

				compH: compH[start:end],

				compI: compI[start:end],

				compJ: compJ[start:end],

				compK: compK[start:end],
			}
		}

		// if workPerformed != len(ids) {
		// 	panic("wrong")
		// }
	}

	close(workChannel)
	waitGroup.Wait()
}

// Deprecated: This API is a tentative alternative way to map
func (v *View11[A, B, C, D, E, F, G, H, I, J, K]) MapSlices(lambda func(id []Id, a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I, j []J, k []K)) {
	v.filter.regenerate(v.world)

	id := make([][]Id, 0)

	sliceListA := make([][]A, 0)
	sliceListB := make([][]B, 0)
	sliceListC := make([][]C, 0)
	sliceListD := make([][]D, 0)
	sliceListE := make([][]E, 0)
	sliceListF := make([][]F, 0)
	sliceListG := make([][]G, 0)
	sliceListH := make([][]H, 0)
	sliceListI := make([][]I, 0)
	sliceListJ := make([][]J, 0)
	sliceListK := make([][]K, 0)

	for _, archId := range v.filter.archIds {

		sliceA, ok := v.storageA.slice.Get(archId)
		if !ok {
			continue
		}
		sliceB, ok := v.storageB.slice.Get(archId)
		if !ok {
			continue
		}
		sliceC, ok := v.storageC.slice.Get(archId)
		if !ok {
			continue
		}
		sliceD, ok := v.storageD.slice.Get(archId)
		if !ok {
			continue
		}
		sliceE, ok := v.storageE.slice.Get(archId)
		if !ok {
			continue
		}
		sliceF, ok := v.storageF.slice.Get(archId)
		if !ok {
			continue
		}
		sliceG, ok := v.storageG.slice.Get(archId)
		if !ok {
			continue
		}
		sliceH, ok := v.storageH.slice.Get(archId)
		if !ok {
			continue
		}
		sliceI, ok := v.storageI.slice.Get(archId)
		if !ok {
			continue
		}
		sliceJ, ok := v.storageJ.slice.Get(archId)
		if !ok {
			continue
		}
		sliceK, ok := v.storageK.slice.Get(archId)
		if !ok {
			continue
		}

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }

		id = append(id, lookup.id)

		sliceListA = append(sliceListA, sliceA.comp)
		sliceListB = append(sliceListB, sliceB.comp)
		sliceListC = append(sliceListC, sliceC.comp)
		sliceListD = append(sliceListD, sliceD.comp)
		sliceListE = append(sliceListE, sliceE.comp)
		sliceListF = append(sliceListF, sliceF.comp)
		sliceListG = append(sliceListG, sliceG.comp)
		sliceListH = append(sliceListH, sliceH.comp)
		sliceListI = append(sliceListI, sliceI.comp)
		sliceListJ = append(sliceListJ, sliceJ.comp)
		sliceListK = append(sliceListK, sliceK.comp)
	}

	for idx := range id {
		lambda(id[idx],
			sliceListA[idx], sliceListB[idx], sliceListC[idx], sliceListD[idx], sliceListE[idx], sliceListF[idx], sliceListG[idx], sliceListH[idx], sliceListI[idx], sliceListJ[idx], sliceListK[idx],
		)
	}
}

// --------------------------------------------------------------------------------
// - View 12
// --------------------------------------------------------------------------------

// Represents a view of data in a specific world. Provides access to the components specified in the generic block
type View12[A, B, C, D, E, F, G, H, I, J, K, L any] struct {
	world  *World
	filter filterList

	storageA *componentStorage[A]
	storageB *componentStorage[B]
	storageC *componentStorage[C]
	storageD *componentStorage[D]
	storageE *componentStorage[E]
	storageF *componentStorage[F]
	storageG *componentStorage[G]
	storageH *componentStorage[H]
	storageI *componentStorage[I]
	storageJ *componentStorage[J]
	storageK *componentStorage[K]
	storageL *componentStorage[L]
}

// implement the intializer interface so that it can be automatically created and injected into systems
func (v *View12[A, B, C, D, E, F, G, H, I, J, K, L]) initialize(world *World) any {
	// TODO: filters need to be a part of the query type
	return Query12[A, B, C, D, E, F, G, H, I, J, K, L](world)
}

// Creates a View for the specified world with the specified component filters.
func Query12[A, B, C, D, E, F, G, H, I, J, K, L any](world *World, filters ...Filter) *View12[A, B, C, D, E, F, G, H, I, J, K, L] {

	storageA := getStorage[A](world.engine)
	storageB := getStorage[B](world.engine)
	storageC := getStorage[C](world.engine)
	storageD := getStorage[D](world.engine)
	storageE := getStorage[E](world.engine)
	storageF := getStorage[F](world.engine)
	storageG := getStorage[G](world.engine)
	storageH := getStorage[H](world.engine)
	storageI := getStorage[I](world.engine)
	storageJ := getStorage[J](world.engine)
	storageK := getStorage[K](world.engine)
	storageL := getStorage[L](world.engine)

	var AA A
	var BB B
	var CC C
	var DD D
	var EE E
	var FF F
	var GG G
	var HH H
	var II I
	var JJ J
	var KK K
	var LL L

	comps := []CompId{

		name(AA),
		name(BB),
		name(CC),
		name(DD),
		name(EE),
		name(FF),
		name(GG),
		name(HH),
		name(II),
		name(JJ),
		name(KK),
		name(LL),
	}
	filterList := newFilterList(comps, filters...)
	filterList.regenerate(world)

	v := &View12[A, B, C, D, E, F, G, H, I, J, K, L]{
		world:  world,
		filter: filterList,

		storageA: storageA,
		storageB: storageB,
		storageC: storageC,
		storageD: storageD,
		storageE: storageE,
		storageF: storageF,
		storageG: storageG,
		storageH: storageH,
		storageI: storageI,
		storageJ: storageJ,
		storageK: storageK,
		storageL: storageL,
	}
	return v
}

// Reads a pointer to the underlying component at the specified id.
// Read will return even if the specified id doesn't match the filter list
// Read will return the value if it exists, else returns nil.
// If you execute any ecs.Write(...) or ecs.Delete(...) this pointer may become invalid.
func (v *View12[A, B, C, D, E, F, G, H, I, J, K, L]) Read(id Id) (*A, *B, *C, *D, *E, *F, *G, *H, *I, *J, *K, *L) {
	if id == InvalidEntity {
		return nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil
	}

	loc, ok := v.world.arch.Get(id)
	if !ok {
		return nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil
	}
	lookup := v.world.engine.lookup[loc.archId]
	if lookup == nil {
		panic("LookupList is missing!")
	}
	// index, ok := lookup.index.Get(id)
	// if !ok {
	// 	return nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil
	// }
	index := int(loc.index)

	var retA *A
	var retB *B
	var retC *C
	var retD *D
	var retE *E
	var retF *F
	var retG *G
	var retH *H
	var retI *I
	var retJ *J
	var retK *K
	var retL *L

	sliceA, ok := v.storageA.slice.Get(loc.archId)
	if ok {
		retA = &sliceA.comp[index]
	}
	sliceB, ok := v.storageB.slice.Get(loc.archId)
	if ok {
		retB = &sliceB.comp[index]
	}
	sliceC, ok := v.storageC.slice.Get(loc.archId)
	if ok {
		retC = &sliceC.comp[index]
	}
	sliceD, ok := v.storageD.slice.Get(loc.archId)
	if ok {
		retD = &sliceD.comp[index]
	}
	sliceE, ok := v.storageE.slice.Get(loc.archId)
	if ok {
		retE = &sliceE.comp[index]
	}
	sliceF, ok := v.storageF.slice.Get(loc.archId)
	if ok {
		retF = &sliceF.comp[index]
	}
	sliceG, ok := v.storageG.slice.Get(loc.archId)
	if ok {
		retG = &sliceG.comp[index]
	}
	sliceH, ok := v.storageH.slice.Get(loc.archId)
	if ok {
		retH = &sliceH.comp[index]
	}
	sliceI, ok := v.storageI.slice.Get(loc.archId)
	if ok {
		retI = &sliceI.comp[index]
	}
	sliceJ, ok := v.storageJ.slice.Get(loc.archId)
	if ok {
		retJ = &sliceJ.comp[index]
	}
	sliceK, ok := v.storageK.slice.Get(loc.archId)
	if ok {
		retK = &sliceK.comp[index]
	}
	sliceL, ok := v.storageL.slice.Get(loc.archId)
	if ok {
		retL = &sliceL.comp[index]
	}

	return retA, retB, retC, retD, retE, retF, retG, retH, retI, retJ, retK, retL
}

// Counts the number of entities that match this query
func (v *View12[A, B, C, D, E, F, G, H, I, J, K, L]) Count() int {
	v.filter.regenerate(v.world)

	total := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		total += lookup.Len()
	}
	return total
}

// Maps the lambda function across every entity which matched the specified filters.
func (v *View12[A, B, C, D, E, F, G, H, I, J, K, L]) MapId(lambda func(id Id, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]
	var compA []A
	var retA *A

	var sliceB *componentList[B]
	var compB []B
	var retB *B

	var sliceC *componentList[C]
	var compC []C
	var retC *C

	var sliceD *componentList[D]
	var compD []D
	var retD *D

	var sliceE *componentList[E]
	var compE []E
	var retE *E

	var sliceF *componentList[F]
	var compF []F
	var retF *F

	var sliceG *componentList[G]
	var compG []G
	var retG *G

	var sliceH *componentList[H]
	var compH []H
	var retH *H

	var sliceI *componentList[I]
	var compI []I
	var retI *I

	var sliceJ *componentList[J]
	var compJ []J
	var retJ *J

	var sliceK *componentList[K]
	var compK []K
	var retK *K

	var sliceL *componentList[L]
	var compL []L
	var retL *L

	for _, archId := range v.filter.archIds {

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)
		sliceF, _ = v.storageF.slice.Get(archId)
		sliceG, _ = v.storageG.slice.Get(archId)
		sliceH, _ = v.storageH.slice.Get(archId)
		sliceI, _ = v.storageI.slice.Get(archId)
		sliceJ, _ = v.storageJ.slice.Get(archId)
		sliceK, _ = v.storageK.slice.Get(archId)
		sliceL, _ = v.storageL.slice.Get(archId)

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }
		ids := lookup.id

		// TODO - this flattened version causes a mild performance hit. But the other one combinatorially explodes. I also cant get BCE to work with it. See option 2 for higher performance.

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}
		compF = nil
		if sliceF != nil {
			compF = sliceF.comp
		}
		compG = nil
		if sliceG != nil {
			compG = sliceG.comp
		}
		compH = nil
		if sliceH != nil {
			compH = sliceH.comp
		}
		compI = nil
		if sliceI != nil {
			compI = sliceI.comp
		}
		compJ = nil
		if sliceJ != nil {
			compJ = sliceJ.comp
		}
		compK = nil
		if sliceK != nil {
			compK = sliceK.comp
		}
		compL = nil
		if sliceL != nil {
			compL = sliceL.comp
		}

		retA = nil
		retB = nil
		retC = nil
		retD = nil
		retE = nil
		retF = nil
		retG = nil
		retH = nil
		retI = nil
		retJ = nil
		retK = nil
		retL = nil
		for idx := range ids {
			if ids[idx] == InvalidEntity {
				continue
			} // Skip if its a hole

			if compA != nil {
				retA = &compA[idx]
			}
			if compB != nil {
				retB = &compB[idx]
			}
			if compC != nil {
				retC = &compC[idx]
			}
			if compD != nil {
				retD = &compD[idx]
			}
			if compE != nil {
				retE = &compE[idx]
			}
			if compF != nil {
				retF = &compF[idx]
			}
			if compG != nil {
				retG = &compG[idx]
			}
			if compH != nil {
				retH = &compH[idx]
			}
			if compI != nil {
				retI = &compI[idx]
			}
			if compJ != nil {
				retJ = &compJ[idx]
			}
			if compK != nil {
				retK = &compK[idx]
			}
			if compL != nil {
				retL = &compL[idx]
			}
			lambda(ids[idx], retA, retB, retC, retD, retE, retF, retG, retH, retI, retJ, retK, retL)
		}
	}
}

// Maps the lambda function across every entity which matched the specified filters. Components are split based on the number of OS threads available.
func (v *View12[A, B, C, D, E, F, G, H, I, J, K, L]) MapIdParallel(lambda func(id Id, a *A, b *B, c *C, d *D, e *E, f *F, g *G, h *H, i *I, j *J, k *K, l *L)) {
	v.filter.regenerate(v.world)

	var sliceA *componentList[A]

	var sliceB *componentList[B]

	var sliceC *componentList[C]

	var sliceD *componentList[D]

	var sliceE *componentList[E]

	var sliceF *componentList[F]

	var sliceG *componentList[G]

	var sliceH *componentList[H]

	var sliceI *componentList[I]

	var sliceJ *componentList[J]

	var sliceK *componentList[K]

	var sliceL *componentList[L]

	// 1. Calculate work
	// 2. Calculate number of threads to execute with
	// 3. Greedy divide work among N threads
	// 4. Execute for each in its own goroutine

	// 1. Calculate work
	totalWork := 0
	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}

		// Each id represents an entity that holds the requested component(s)
		// Each hole represents a deleted entity that used to hold the requested component(s)
		totalWork += len(lookup.id) // - len(lookup.holes)
	}

	// 2. Calculate number of threads to execute with
	numThreads := runtime.NumCPU()
	var waitGroup sync.WaitGroup

	type workItem struct {
		ids []Id

		compA []A

		compB []B

		compC []C

		compD []D

		compE []E

		compF []F

		compG []G

		compH []H

		compI []I

		compJ []J

		compK []K

		compL []L
	}
	workChannel := make(chan workItem)

	for i := 0; i < numThreads; i++ {
		waitGroup.Add(1)
		go func() {
			defer waitGroup.Done()

			for {
				work, ok := <-workChannel
				if !ok {
					return
				}

				var retA *A
				var retB *B
				var retC *C
				var retD *D
				var retE *E
				var retF *F
				var retG *G
				var retH *H
				var retI *I
				var retJ *J
				var retK *K
				var retL *L
				for idx := range work.ids {
					if work.ids[idx] == InvalidEntity {
						continue
					} // Skip if its a hole

					if work.compA != nil {
						retA = &work.compA[idx]
					}
					if work.compB != nil {
						retB = &work.compB[idx]
					}
					if work.compC != nil {
						retC = &work.compC[idx]
					}
					if work.compD != nil {
						retD = &work.compD[idx]
					}
					if work.compE != nil {
						retE = &work.compE[idx]
					}
					if work.compF != nil {
						retF = &work.compF[idx]
					}
					if work.compG != nil {
						retG = &work.compG[idx]
					}
					if work.compH != nil {
						retH = &work.compH[idx]
					}
					if work.compI != nil {
						retI = &work.compI[idx]
					}
					if work.compJ != nil {
						retJ = &work.compJ[idx]
					}
					if work.compK != nil {
						retK = &work.compK[idx]
					}
					if work.compL != nil {
						retL = &work.compL[idx]
					}
					lambda(work.ids[idx], retA, retB, retC, retD, retE, retF, retG, retH, retI, retJ, retK, retL)
				}
			}
		}()
	}

	// 3. Greedy divide work among N threads
	// Simple algorithm:
	// a. Find an evenly balanced distribution per thread
	// b. Generate all work until it gets consumed
	workPerThread := totalWork / numThreads

	// Generate

	var compA []A

	var compB []B

	var compC []C

	var compD []D

	var compE []E

	var compF []F

	var compG []G

	var compH []H

	var compI []I

	var compJ []J

	var compK []K

	var compL []L

	for _, archId := range v.filter.archIds {
		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		ids := lookup.id

		sliceA, _ = v.storageA.slice.Get(archId)
		sliceB, _ = v.storageB.slice.Get(archId)
		sliceC, _ = v.storageC.slice.Get(archId)
		sliceD, _ = v.storageD.slice.Get(archId)
		sliceE, _ = v.storageE.slice.Get(archId)
		sliceF, _ = v.storageF.slice.Get(archId)
		sliceG, _ = v.storageG.slice.Get(archId)
		sliceH, _ = v.storageH.slice.Get(archId)
		sliceI, _ = v.storageI.slice.Get(archId)
		sliceJ, _ = v.storageJ.slice.Get(archId)
		sliceK, _ = v.storageK.slice.Get(archId)
		sliceL, _ = v.storageL.slice.Get(archId)

		compA = nil
		if sliceA != nil {
			compA = sliceA.comp
		}
		compB = nil
		if sliceB != nil {
			compB = sliceB.comp
		}
		compC = nil
		if sliceC != nil {
			compC = sliceC.comp
		}
		compD = nil
		if sliceD != nil {
			compD = sliceD.comp
		}
		compE = nil
		if sliceE != nil {
			compE = sliceE.comp
		}
		compF = nil
		if sliceF != nil {
			compF = sliceF.comp
		}
		compG = nil
		if sliceG != nil {
			compG = sliceG.comp
		}
		compH = nil
		if sliceH != nil {
			compH = sliceH.comp
		}
		compI = nil
		if sliceI != nil {
			compI = sliceI.comp
		}
		compJ = nil
		if sliceJ != nil {
			compJ = sliceJ.comp
		}
		compK = nil
		if sliceK != nil {
			compK = sliceK.comp
		}
		compL = nil
		if sliceL != nil {
			compL = sliceL.comp
		}

		// workPerformed := 0

		start := 0
		end := 0
		numWorkItems := (len(ids) / workPerThread) + 1
		actualWorkPerThread := (len(ids) / numWorkItems) + 1
		for i := 0; i < numWorkItems; i++ {
			start = i * actualWorkPerThread
			end = (i + 1) * actualWorkPerThread
			if end > len(ids) {
				end = len(ids)
			}

			// workPerformed += len(ids[start:end])
			workChannel <- workItem{
				ids: ids[start:end],

				compA: compA[start:end],

				compB: compB[start:end],

				compC: compC[start:end],

				compD: compD[start:end],

				compE: compE[start:end],

				compF: compF[start:end],

				compG: compG[start:end],

				compH: compH[start:end],

				compI: compI[start:end],

				compJ: compJ[start:end],

				compK: compK[start:end],

				compL: compL[start:end],
			}
		}

		// if workPerformed != len(ids) {
		// 	panic("wrong")
		// }
	}

	close(workChannel)
	waitGroup.Wait()
}

// Deprecated: This API is a tentative alternative way to map
func (v *View12[A, B, C, D, E, F, G, H, I, J, K, L]) MapSlices(lambda func(id []Id, a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I, j []J, k []K, l []L)) {
	v.filter.regenerate(v.world)

	id := make([][]Id, 0)

	sliceListA := make([][]A, 0)
	sliceListB := make([][]B, 0)
	sliceListC := make([][]C, 0)
	sliceListD := make([][]D, 0)
	sliceListE := make([][]E, 0)
	sliceListF := make([][]F, 0)
	sliceListG := make([][]G, 0)
	sliceListH := make([][]H, 0)
	sliceListI := make([][]I, 0)
	sliceListJ := make([][]J, 0)
	sliceListK := make([][]K, 0)
	sliceListL := make([][]L, 0)

	for _, archId := range v.filter.archIds {

		sliceA, ok := v.storageA.slice.Get(archId)
		if !ok {
			continue
		}
		sliceB, ok := v.storageB.slice.Get(archId)
		if !ok {
			continue
		}
		sliceC, ok := v.storageC.slice.Get(archId)
		if !ok {
			continue
		}
		sliceD, ok := v.storageD.slice.Get(archId)
		if !ok {
			continue
		}
		sliceE, ok := v.storageE.slice.Get(archId)
		if !ok {
			continue
		}
		sliceF, ok := v.storageF.slice.Get(archId)
		if !ok {
			continue
		}
		sliceG, ok := v.storageG.slice.Get(archId)
		if !ok {
			continue
		}
		sliceH, ok := v.storageH.slice.Get(archId)
		if !ok {
			continue
		}
		sliceI, ok := v.storageI.slice.Get(archId)
		if !ok {
			continue
		}
		sliceJ, ok := v.storageJ.slice.Get(archId)
		if !ok {
			continue
		}
		sliceK, ok := v.storageK.slice.Get(archId)
		if !ok {
			continue
		}
		sliceL, ok := v.storageL.slice.Get(archId)
		if !ok {
			continue
		}

		lookup := v.world.engine.lookup[archId]
		if lookup == nil {
			panic("LookupList is missing!")
		}
		// lookup, ok := v.world.engine.lookup[archId]
		// if !ok { panic("LookupList is missing!") }

		id = append(id, lookup.id)

		sliceListA = append(sliceListA, sliceA.comp)
		sliceListB = append(sliceListB, sliceB.comp)
		sliceListC = append(sliceListC, sliceC.comp)
		sliceListD = append(sliceListD, sliceD.comp)
		sliceListE = append(sliceListE, sliceE.comp)
		sliceListF = append(sliceListF, sliceF.comp)
		sliceListG = append(sliceListG, sliceG.comp)
		sliceListH = append(sliceListH, sliceH.comp)
		sliceListI = append(sliceListI, sliceI.comp)
		sliceListJ = append(sliceListJ, sliceJ.comp)
		sliceListK = append(sliceListK, sliceK.comp)
		sliceListL = append(sliceListL, sliceL.comp)
	}

	for idx := range id {
		lambda(id[idx],
			sliceListA[idx], sliceListB[idx], sliceListC[idx], sliceListD[idx], sliceListE[idx], sliceListF[idx], sliceListG[idx], sliceListH[idx], sliceListI[idx], sliceListJ[idx], sliceListK[idx], sliceListL[idx],
		)
	}
}
